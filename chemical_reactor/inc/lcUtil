/*** ^^A -*-C++-*- **********************************************/
/*	lcUtil 2011-03-02					*/
/****************************************************************/
/*	Short Description :					*/
/*	This file contains functions and definitions for LC-NMR */
/*	AU programs.						*/
/****************************************************************/
/*	Keywords :						*/
/*	LCNMR							*/
/****************************************************************/
/*	Author(s) :						*/
/*	Name		: Ulrich Braumann			*/
/*	Organisation	: Bruker BioSpin GmbH, Germany		*/
/*	Email		: ulrich.braumann@bruker-biospin.de	*/
/****************************************************************/
/*	Name	Date	Modification:				*/
/*	eub	001007	#define NAMEF1LISTCURD solvents.f1list	*/
/*	eub	001016	debug error in ZgSino			*/
/*	eub	001023	error CreateScaleShape			*/
/*	eub	001217	Keyword for PSCAL, and CMD-Par introd.	*/
/*	eub	001220	Setupprocedures enhanced, Id-String	*/
/*	eub	001221	German char removed, ReadFrqOn corected */
/*	eub	010604	New fnct GenReg2, RegInters		*/
/*			Keyword 1r-zero, headers reformated	*/
/*	eub	010626	setup proc. changed, KEYW_OFFRES	*/
/*	eub	010807	MAX_SWDQD				*/
/*	eub	010823	reorganisation				*/
/*	eub	010921	Version in FktId short			*/
/*	eub	020627	OnFlTimeRes without NDO			*/
/*	eub	020705	DetRG changes DE to 50u			*/
/*	eub	030212	func. ReadFrqUser, ReadFrqLst changed	*/
/*			mqfil applies quad/single/no at O1	*/
/*	eub	030303	DetRg, SetupDetRg modif. for cryo	*/
/*	eub	030325	RG-Setup corrected			*/
/*	eub	030924	msino changes PHC0 after nm		*/
/*	eub	040308	Variables for TOPSPIN changed		*/
/*			Keyword for solvent number check	*/
/*			CalcExpTime internal function		*/
/*	eub	040310	Max Solvents, Searchlimits 2D		*/
/*	eub	041102	FUNCTION AcquSave Increase sleeptime	*/
/*	eub	041111	AcquSave2, Incr. acqu delay		*/
/*	eub	041124	ZGSino2, SetupSino1D2			*/
/*	eub	041125	check_autoshim				*/
/*	eub	041214	Use of DBL checked			*/
/*	eub	041221	Debug SINO control			*/
/*	eub	041222	SinoMin CNST28, DE auto setup, misc.	*/
/*			hsqc in pplist				*/
/*	eub	050627	func KeyWords ->SetupAcqu1d, lcshlrun	*/
/*	eub	050818	fopen for text files with "wt"		*/
/*			pulprog lists completed			*/
/*			func sref2 started			*/
/*			use ReadFrqOn_2 (repl. ReadFrqOn	*/
/*	eub	051129	func ReScale for NS/RG scaling		*/
/*	eub	051203	func PhaseCorr, formatting streamlined	*/
/*	eub	060110	AcquSave2 w/o ZGSAFETY, w/o stdio	*/
/*			AcquSave uses AcquSave2			*/
/*	eub	060704	Define for DE_cryo, SCALE_RG, SCALE_NS	*/
/*	eub	070301	function FindFirst,EndAU,SetupSino2D2	*/
/*			debug as textfile			*/
/*	gsc	070813	check_autoshim uses CPR_exec(autoshim)	*/
/*			to allow usage on IPSO too		*/
/*	eub	080101	Modifications from 2.0.5 imported	*/
/*			ReadInteg, FindFirst			*/
/*	eub	080131	cosycwgppsqf in MAXSOLV_n, phase 'e' in */
/*			in CreateScaleShape			*/
/*	eub	080310	ZgSino2 halt->stop to avoid odd NS	*/
/*	eub	080311	RepLine with corr. of '\n' at EOF	*/
/*	eub	080323	RepLine with Show_meta for title	*/
/*	eub	080324	IniAu_2, EndAu reformated, KEYW_SUMMARY */
/*	eub	080605	lc2grdonflow in MAXSOLV_n		*/
/*			Scaling Standard for RG&NS 1->128	*/
/*	eub	080902	msino stores SINO correctly		*/
/*	eub	090205	Modification: of SetupSino1D2,		*/
/*			SetupAcqu1D, SetupSSearch, KeyWords,	*/
/*			check_autoshim.				*/
/*			New: SetupInfo, SetupInfo2, LockInfo	*/
/*			KEYW for pulsecal and saveprofpars	*/
/*			PhaseCorr with apk0.noe			*/
/*	eub	090807	Use -dBW, IniAU + EndAu without USER	*/
/*			KeyWords_2				*/
/*	eub	090819	WritePeakFile XML, Formatted, pow_next	*/
/*			WetPlSet corr.				*/
/*	eub	110124	DetRg: RGMax ignored (KB10078)		*/
/*			ReScale with P1 evaluation		*/
/*	eub	110302	WritePeakFile_2: Use SR, format corr.	*/
/****************************************************************/
/*
$Id: lcUtil,v 1.48.2.3 2011/03/03 16:13:58 wem Exp $
*/

#include <inc/exptUtil>
#include <lib/sxutil.h>
#include <lib/libacq.h>
#include <lib/lib_sbsb.h>

#ifdef _MSC_VER /* native Visual C++ */
#define strcasecmp _stricmp
#endif

extern int DBL;

/* with "1" all acquisition commands are bypassed */
/* usefull for demonstration without spectrometer */
#define DEMO_MODE 0

/* maximum number for array which hold peak information */
#define MAXPEAKNR 511
/* Maximum number of solvents which are extracted from the peaks */
#define MAXSOLVNR 32
/* Max SWH possible with DQD */
#define MAX_SWDQD 25000.
/* Max delay to wait for termination of stop, ii command */
#define MAX_ACQUREADY 10
/* Automatic DE for CryoProbe */
#define DE_CRYO 40.

/* Default values for scaling via rescale */
#define SCALE_RG 128.
#define SCALE_NS 128



#define STRING_MAXLENGTH 1024
#define NAMEF1LISTCURD "solvents.f1list"
#define NAMEPEAKFILECURD "solvents.peaks"
#define NAMEMDCONCURD "solvents.mdcon"
#define NAMEREGCURD "solvents.reg"
#define KEYW_SOLV   "Solvent(s)      : "
#define KEYW_SINO1D "Signal-to-noise : "
#define KEYW_SUMMARY "Summary         : "
#define KEYW_SETUP "setup-yes"
#define KEYW_WET_NO "wet-no"
#define KEYW_TITLE_NO "title-no"
#define KEYW_FRQKORR_YES "frqcorr-yes"
#define KEYW_ZEROSOLV_YES "1r-zero"
#define KEYW_OFFRES "offres"
#define KEYW_ADJXDECPOS_NO "adjxdecpos-no"
#define KEYW_PUlSECAL_YES "pcal-yes"
#define KEYW_PUlSECAL_FAST_YES "pcalf-yes"
#define KEYW_SAVEPROF_YES "sprof-yes"
#define KEYW_GETPROF_YES "gprof-yes"
#define MAXSOLV_0 "_lc2_lc2pg_"
#define MAXSOLV_1 "_lc1pncw_lc2pn_lc2pr_lcjrescwprqf_lcjresprqf_lcmlevpcph_mlevphpr_zgpr_zggppr_noesygppr1d_noesypr1d_"
#define MAXSOLV_2 "_lc1pncwfd_lc1pnf2_lc1prf2_lc2pnf2_lc2prf2_lcjrescwfdprqf_lcjresf2prqf_lcmlevcwfdpcph_lcmlevf2pcph_lcmlevf2phpr_"
#define MAXSOLV_3 "_lc1pnft_"
#define MAXSOLV_n "_lc1pncwps_lc1pnfr_lc1pnps_lc1prft_zgps_wet_wetdc_wetdw_lc2pnps_lc2ps_lc2wetdc_lc2wetdcus_lcjrescwpsqf_lcjrespsqf_lcmlevcwpcphps_lcmlevpcphps_mlevdcphwt_cosycwphps_cosydcphwt_cosycwgppsqf_hsqcetgpsiwt_lc2grdonflow_"

#define PSCAL_GLOBAL 0
#define PSCAL_PREG   1
#define PSCAL_IREG   2
#define PSCAL_PIREG  3
#define PSCAL_SREG   4
#define PSCAL_PSREG  5
#define PSCAL_NOISE  6

int DBL = -1;


/* General utilities for AU progs *********************************************/
void  AUMessage( const char *Message );
int   IniAu( const char *AuId );
int   IniAu_2( const char *AuId, const char *NMRAData, const char *NMRPData );
void  EndAu( const char *AuId, const char *Message );
void  EndAu_2( const char *AuId, const char *Message, int Function );
int   SolvInfo( char *Info, int Column, int FrqNrMax, double *SFrq, double *SFrqP );
int   sref2( const char *curdat );
int   FindFirst
( const char *DiskStart, const char *UserStart, const char *NameStart,
  int *ExpStart, int ExpStep, int ExpEnd,
  int *ProcStart, int ProcStep, int ProcEnd,
  const char *ObjName);


/* File In-/Output ************************************************************/
int ReadPeakList
( char *PeakListFP, int PkAnzMax, double *Frq, double *Hwb, double *PrzGauss );
int WritePeakList
( char *PeakListFP, int FrqAnz, double *Frq, double *Hwb, double *PrzGauss );
int ReadPeakFile
( const char *PeakFP, int PkAnzMax, double *Adr, double *Frq, double *FrqP, double *Int );
int ReadPeakFile_2
( const char *PeakFP, int PkAnzMax, double *Adr, double *Frq, double *FrqP, double *Int );
int WritePeakFile_2
( const char *curdat, const char *PeakFP, int FrqAnz, double *Adr, double *Frq, double *FrqP, double *Int, float SR1Dppm );
int WritePeakFile
( const char *curdat, const char *PeakFP, int FrqAnz, double *Adr, double *Frq, double *FrqP, double *Int );
int ReadMdconF
( char *FileP, int PkAnzMax, double *FrqP, double *Hwb, double *Err );
int ReadFrqList
( const char *FrqLstP, int FrqAnzMax, float SR, double *Frq, double *FrqP );
int WriteFrqList( const char *FrqListFP, int FrqAnz, double BF1Set, double *Frq  );
int WriteFrqList2( const char *FrqListFP, int FrqAnz, double BF1Set, double *Frq, double SR );
int WriteRegFile( const char *RegFP, int RegionAnz, double *Border );
int ReadRegFile( const char *RegFP, int RegAnzMax, double *Reg );
int ReadSregLst( const char *SregP, int RegAnzMax, double *Reg );
int WriteSregLst( const char *SregP, int RegAnz, double *Reg );
int ReadInteg
( const char *InputFP, int RegAnzMax, double *Reg, double *Int);
int RepLine
( const char *curdat, const char *FileP, const char *KeyW, const char *Info );
int FindLine
( const char *curdat, const char *FileP, const char *KeyW, char *Info );
int ReadFrqUser
( const char *curdat, int FrqAnzMax, float SR, int SFrqAnzAkt, double *Frq, double *FrqP );
int KeyWords
( char *KeyW, int Position, const char *Action, const char *KeyWAkt, const char *KeyWNew );
int KeyWords_2
( char *KeyW, int Position, const char *Action, const char *KeyWAkt, const char *KeyWNew, const char *FoundMsg );

/* Handling of regions and lists **********************************************/
int SortDouble( int Entries, int *Inx, double *Val );
int GenReg( int AnzEntr, double *Border );
int FilterList
( int ListItm, double *List, double *RList, int *Inx, double *Reg, int RegAnz, int Cond  );

/* Shape handling *************************************************************/
int CalcPresScale ( double *pInn, float *pScale, int AnzFrq );
int CreateScaleShape
( double *pFrq, float *pScale, int AnzFrequ, float PulseLength, const char* ShapeStart, const char* ShapeWork, float *pShapeInteg );
int WetPlSet( const char *curdat, const char* RefShape, double RefPL, double RefOffs, double WPLKorr );

int SetSFO( const char *curdat, int AnzSolv, double *pFrq, double *FrqDef, int MaxChannel );
int lcapkff( const char *curdat, float ABSF1Proc, float ABSF2Proc );

/* Timing *********************************************************************/
/* XWINNMR int CalcExpTime(char *curdat ); */
int CalcExpTime35( const char *curdat ); /* TOPSPIN internal function!	*/
int TimePerScan( const char *curdat , double *TimePerScanInt );
int OnFlTimeRes( const char *curdat, double *TimeRes );

/* Special parameter handling *************************************************/
int GetFrqLstP( const char *curdat, char *FrqLstP );
int SpecificName ( const char *curdat, char *SName, int GesLen );
int ReadFrqOn_2( const char *curdat, float SR, double *Frq, double *FrqP, int Mode );
/* ReadFrqOn supplied for compatibility only, for NEW developments use ReadFrqOn_2 */
int ReadFrqOn( const char *curdat, float SR, double *Frq, double *FrqP );

/* Acquisition commands *******************************************************/
int DetRG
(const char *curdat, double RGStrt, double RGMin, double RGMax, double RGCtrl, double RGDef);
int AcquSave( const char *curdat, const char *AcquCmd );
int AcquSave2( const char *curdat, const char *AcquCmd, int ExecOption );
int AcquRun( const char *curdat, int TimeOutMax );
int AcquEnd( const char *curdat, const char *AcquCmd );
int TrN( const char *curdat, int NSSet, float TimeOutMaxSet );
int ZgSino
(const char *curdat, int NSMin, int NSMax, double SinoMin, double SinoMax);
int ZgSino2
(const char *curdat, int NSMin, double SinoMin, double SinoMax );
int check_autoshim(void);
int LockInfo(int *LockStatusExt, double *LockLevelExt, double *LockNoiseExt);

/* Processing *****************************************************************/
int msino( const char *curdat, int AnzReg, double *Reg, double *SINOBest );
int mzero( const char *curdat, int RegAnz, double *Reg );
int lcabsff( const char *curdat, int AnzReg, double *Reg, double LimitH, double LimitL);
int mqfil( const char *curdat, int FrqAnz, double *Frq );
double ReScale( const char *curdat, float RGRef, int NSRef, double P1Ref, int DoMulc );
int PhaseCorr( const char *curdat, int PhasingMode );
int Extract( const char *curdat, double From, double To, const char* Unit, const char* ExtrType, int ProcnoTarget);

/* Interactive setup procedures ***********************************************/
int SetupSino1D( const char *curdat );
int SetupSino1D2( const char *curdat );
int SetupSino2D( const char *curdat );
int SetupSino2D2( const char *curdat );
int SetupDetRG( const char *curdat );
int SetupPrep( const char *curdat );
int SetupWET( const char *curdat );
int SetupSSearch( const char *curdat );
int SetupAcqu1D( const char *curdat );
int SetupAcqu2D( const char *curdat );
int SetupOnflow( const char *curdat );
int SetupOnflow2( const char *curdat );
int SetupMessage( const char *curdat );
int SetupMessage2( const char *curdat );




/* FUNCTION IniAU_2 ***********************************************************/
/* Initializes the debug file and DBL level flag, prints the default start-   */
/* message into the debug file.						      */
/* Optionally checks for existing NMR data to prevent that AU programs that   */
/* require NMR data are started from edte,topshim, ...			      */
/******************************************************************************/
/* eub 080324 Created from func IniAU, Check for existing NMR data included   */
/*	      Report time of start, dataset separate from AuId		      */
/* eub 080529 time format changed, NMR check changed			      */
/* eub 080622 Check for arbitrary NMR data in ACQU and PROCPATH		      */
/* eub 090807 Datastructure without USER				      */
/******************************************************************************/
int   IniAu_2( const char *AuId, const char *NMRAData,	const char *NMRPData )
{
  char	 *pt;
  char	 *DBLEnvSet;
  time_t tloc = time(0);
  int	 RetVal = 0;
  char	 TempStr[128] = "";

  /* Initialize debug file and set debuglevel */
  if (!debug && (pt = getenv("DEBUG_BPSU"))!= NULL)
  {
    /* If debug is not already set but 'DEBUG_BPSU' is set */
    debug = fopen(pt,"at");
  }

  if (debug)
  {
    /* debug exists so print at least the AuId */
    fflush(debug);
    strftime(TempStr, sizeof(TempStr), "%Y-%m-%d %H:%M:%S", localtime(&tloc));
    (void)fprintf(debug,"\n\nSTART %s ['%s' '%s' %d %d] %s\n\n"
      ,AuId,disk,name,expno,procno,TempStr);

    /* Generate pointer to variable */
    DBLEnvSet =  getenv("DEBUGLEVEL");

    if ( DBLEnvSet != NULL )
    {
      /* if variable exists try to read integer from it */
      if ( sscanf(DBLEnvSet,"%d",&DBL ) != 1 )
      {
	/* if extraction of value fails it is reset to 0 */
	DBL = 0;
      }
    }
    /* Debuglevel was read, report it */
    if(DBL>0)
      (void)fprintf(debug,"\nDBL=%d\n",DBL);
    fflush(debug);
  }
  else
  {
    DBL = -1;
  }

  /* check if the userspecified NMR data is available AU-program */
  if( NMRAData[0]!=0 && access(ACQUPATH(NMRAData),F_OK) )
  {
    if(debug)
      (void)fprintf(debug,"\nABORT '%s' not found\n",ACQUPATH(NMRAData));
    RetVal= -1;
  }
  if( NMRPData[0]!=0 && access(PROCPATH(NMRPData),F_OK) )
  {
    if(debug)
      (void)fprintf(debug,"\nABORT '%s' not found\n",PROCPATH(NMRPData));
    RetVal= -1;
  }

  return(RetVal);
}
/******************************************************************************/


/* FUNCTION IniAU *************************************************************/
/* eub 010807 add. DBL decl. removed, use DEBUGLEVEL set from debugmod	      */
/* eub 010921 Setting of DBL and debug + reporting changed		      */
/* eub 070109 Write debug as TEXT file					      */
/* eub 030824 Content replaced by func IniAU_2				      */
/* eub 080622 Number of arguments changed				      */
/******************************************************************************/
int IniAu( const char *AuId )
{

  IniAu_2( AuId, "", "" );

  return( DBL );
}
/******************************************************************************/


/* FUNCTION EndAU *************************************************************/
/* prints 'Message' and the standard 'END' text into the debug dile	      */
/* flushes and closes the debugfile					      */
/* Message can by empty, must terminat with '\n if it contains text	      */
/******************************************************************************/
/* eub 061003 created							      */
/* eub 080529 date added, dataset separate from AuId			      */
/* eub 090807 Datastructure without USER				      */
/******************************************************************************/
void EndAu( const char *AuId, const char *Message )
{
  time_t tloc = time(0);
  char DateStr[128] = "";

  if (debug)
  {
    fflush(debug);

    /* Create time information */
    strftime(DateStr, sizeof(DateStr), "%Y-%m-%d %H:%M:%S", localtime(&tloc));

    (void)fprintf(debug,"\n%sEND   %s ['%s' '%s' %d %d] %s\n\n"
      ,Message,AuId,disk,name,expno,procno,DateStr);
    fflush(debug);
    fclose(debug);
  }
}
/******************************************************************************/


/******************************************************************************/
/* FUNCTION EndAU_2 ***********************************************************/
/* prints 'Message' and the standard 'END' text into the debug dile           */
/* flushes and closes the debugfile                                           */
/* Message can by empty, must terminat with '\n if it contains text           */
/* Optionally the 'Message' can be shown to the user                          */
/******************************************************************************/
/* eub 061003 created                                                         */
/* eub 080529 date added, dataset separate from AuId                          */
/******************************************************************************/
void EndAu_2( const char *AuId, const char *Message, int Function )
{
  char DateStr[128];
  time_t tloc = time(0);

  if( Function >= 3 )
  {
    Proc_err(Function-3,"= END %s ==========\n%s",AuId,Message);
  }

  if (debug)
  {
    fflush(debug);

    /* Create time information */
    DateStr[0] = 0;
    strftime(DateStr, sizeof(DateStr), "%Y-%m-%d %H:%M:%S", localtime(&tloc));

    (void)fprintf(debug,"\n%sEND   %s ['%s' '%s' '%s' %d %d] %s\n\n"
      ,Message,AuId,disk,user,name,expno,procno,DateStr);
    fflush(debug);
    fclose(debug);
  }
}
/******************************************************************************/

/* FUNCTION SolvInfo **********************************************************/
/* Adds the values from SFrqP in PPM and SFrq in Hz to a 'Info'. Each line    */
/* contains 'Column' frequencies. 'SFrq' can be NULL.			      */
/* 010920 eub first version						      */
/******************************************************************************/
int SolvInfo
( char *Info, int Column, int FrqNrMax, double *SFrq, double *SFrqP )
{
  static const char FktId[] = "SolvInfo 010920";
  int  SFrqNr;
  char TempStr[PATH_MAX] = "";

  for( SFrqNr=0; SFrqNr<FrqNrMax; SFrqNr++ )
  {
    if( SFrqP != NULL )
      sprintf(TempStr,"%s%.2fppm",TempStr,SFrqP[SFrqNr]);
    if( SFrq != NULL )
      sprintf(TempStr,"%s(%.0fHz)",TempStr,SFrq[SFrqNr]);
    if( (SFrqNr+1)!=FrqNrMax )
    {
      /* Not the last entry */
      if( ((SFrqNr+1) % Column) == 0 )
      {
	strcat(TempStr,"\n");
      }
      else
      {
	strcat(TempStr,"  ");
      }
    }
  }
  strcat(Info,TempStr);
  if(debug)
  {
    fprintf(debug,"<FUNCTION\t%s: '%s'\n",FktId,Info);
    fflush(debug);
  }

  return 0;
}

/* FUNCTION sref2 *************************************************************/
/* improved SREF command						      */
/* eub 050818 created							      */
/******************************************************************************/
int   sref2( const char *curdat )
{
  static const char FktId[] = "sref2 050818";

  double LockShift = 0;
  double Reference = 0;

  if( LockShift == Reference )
  {
    /* Lock and Ref signal are the same */
    /* LOCK command already references the spectrum */
    if (debug)
    {
      (void)fprintf(debug,"Lock and Reference identical, no action\n");
      fflush(debug);
    }
  }
  else
  {
    /* baseline correct region */
    /* lcsetsup region with 1 signal */
    /* Set inten signal to reference */
  }

  if (debug)
  {
    (void)fprintf(debug,"<FUNCTION '%s': WARNING not yet implemented\n",FktId);
    fflush(debug);
  }

  return(0);

}
/* END FUNCTION sref2 *********************************************************/


/* FUNCTION FindFirst *********************************************************/
/* Searches for files in a sequence of expno/procno in the dataset defined by */
/* DiskStart,UserStart, NameStar					      */
/* Define expno range with ExpStart, ExpStep, ExpEnd			      */
/* Search for acquisition files like 'fid' or 'acqu' with ProcStart = 0       */
/* Search for processing files like '1r' or 'proc' with ProcStart >= 0	      */
/* Set ObjName for example 'fid', 'acqu', '1r', ...			      */
/* Return=-1 if not found, =0 if found					      */
/* Attention, value of ExpStart and ProcStart is changed if dataset is found  */
/* by carefull when using 'expno' or 'procno' as variables		      */
/******************************************************************************/
/* Examples								      */
/* Search if an FID exists in any expno between 10 to 100 (Procno not used)   */
/* newexpno=10;								      */
/* FindFirst(disk,user,name,newexpno,1,100,NULL,0,0,"fid");		      */
/* Search if a 2D Spectrum exists in any Expno between 11 to 19 on any procnos*/
/* between 1 - 1000							      */
/* newexpno=11; newprocno=1						      */
/* FindFirst(disk,user,name,newexpno,1,19,newprocno,1,100,"2rr");	      */
/* Notes:								      */
/* If you want to find the NEXT expno you must start searching on expno+1     */
/* otherwise the current expno is found.				      */
/* Do not enter '0' as Procno, a variable or 'NULL' must be used	      */
/******************************************************************************/
/* 060913 eub first version						      */
/* 070305 wem variable usage corrected (Pointers)			      */
/* 070530 eub treatment of PROCNO simplified				      */
/* 080717 eub new datastructure with & without 'user'			      */
/******************************************************************************/
int FindFirst
( const char *DiskStart, const char *UserStart, const char *NameStart,
 int *ExpStart, int ExpStep, int ExpEnd,
 int *ProcStart, int ProcStep, int ProcEnd,
 const char *ObjName)
{
  static const char FktId[] = "FindFirst 080717";
  int	Found = -1;
  char	ObjPath[PATH_MAX];
  int	SearchMode = 1; /* 0=search for NON existing, 1=search for existing */
  char	SearchName[PATH_MAX];

  /* original dataset */
  char	DiskSave[PATH_MAX], UserSave[PATH_MAX], NameSave[PATH_MAX];
  int	ExpnoSave, ProcSave;

  if (debug)
  {
    (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* check for valid steps */
  if( ExpStep == 0 )
  {
    if(debug)
      fprintf(debug,"ERROR ExpStep = %d, reset to %d\n",ExpStep,1);
    ExpStep = 1;
  }
  if( ProcStep == 0 )
  {
    if(debug)
      fprintf(debug,"ERROR ProcStep = %d, reset to %d\n",ProcStep,1);
    ProcStep = 1;
  }


  /* Search dataset with or without specified item */
  if( ObjName[0]=='-' )
  {
    SearchMode=0;
    sprintf(SearchName,"%s",ObjName+1);
    if(debug)
      fprintf(debug,"Find first dataset withOUT '%s'\n",SearchName);
  }
  else
  {
    strcpy(SearchName,ObjName);
    if(debug)
      fprintf(debug,"Find first dataset with '%s'\n",SearchName);
  }

  /* if if looking in the PROC or ACQU directory */
  if( ProcStart == NULL )
  {
    /* Special treatment, if no Proc-Loop is required */
    ProcEnd = 1;
    ProcStep = 1;
    if(debug)
      fprintf(debug,"Search expno %d,%d... %d\n'"
      ,*ExpStart,*ExpStart+ExpStep,ExpEnd);
  }
  else
  {
    if(debug)
      fprintf(debug,"Search expno %d,%d... %d and Procno %d,%d...%d\n"
      ,*ExpStart,*ExpStart+ExpStep,ExpEnd,*ProcStart,ProcStep,ProcEnd);
  }

  /* remember original dataset */
  strcpy(DiskSave,disk);
  strcpy(UserSave,user);
  strcpy(NameSave,name);
  ExpnoSave = expno;
  ProcSave = procno;

  if(debug)
  {
    fprintf(debug,"Start from Dataset '%s'\n",ACQUPATH(""));
    fflush(debug);
  }

  /* start values for search loop */
  strcpy(disk,DiskStart);
  strcpy(user,UserStart);
  strcpy(name,NameStart);
  expno = *ExpStart;

  while( (ExpStep > 0 && expno <= ExpEnd) || (ExpStep < 0 && expno >= ExpEnd) )
  {

    if( ProcStart == NULL )
      procno = 1;
    else
      procno = *ProcStart;

    while( (ProcStep > 0 && procno <= ProcEnd) || (ProcStep < 0 && procno >= ProcEnd) )
    {
      /* create first part of search object */
      if( ProcStart == NULL )
      {
	sprintf(ObjPath,ACQUPATH(SearchName) );
      }
      else
      {
	sprintf(ObjPath,PROCPATH(SearchName) );
      }
      if(DBL > 0)
      {
	fprintf(debug,"'%s' ->",ObjPath);
	fflush(debug);
      }

      /* findout if (not)exists */
      if( access(ObjPath,F_OK) == 0 )
      {
	/* file FOUND */
	if(DBL > 0)
	  fprintf(debug," exist");
	if( SearchMode==1 )
	{
	  /* found is o.k. so save and break */
	  Found = 0;
	  *ExpStart = expno;
	  if( ProcStart != NULL )
	    *ProcStart = procno;
	  if(DBL > 0)
	    fprintf(debug," o.k.!\n");
	  break;
	}
      }
      else
      {
	/* file NOT found */
	if(DBL > 0)
	  fprintf(debug," no   ");
	if( SearchMode==0 )
	{
	  /* not found is o.k. so save and break */
	  Found = 0;
	  *ExpStart = expno;
	  if( ProcStart != NULL )
	    *ProcStart = procno;
	  if(DBL > 0)
	    fprintf(debug," o.k.!\n");
	  break;
	}
      }


      /* Go to next path */
      if(DBL > 0)
      {
	fprintf(debug," continue\n");
	fflush(debug);
      }
      procno += ProcStep;

    }
    if( Found==0 )
    {
      if(DBL > 0)
	fprintf(debug," search successfully finished\n");
      break;
    }

    /* Increment Expno */
    expno += ExpStep;
  }

  /* return to original dataset */
  strcpy(disk,DiskSave);
  strcpy(user,UserSave);
  strcpy(name,NameSave);
  expno = ExpnoSave;
  procno = ProcSave;

  if(debug)
  {
    fprintf(debug,"\\END\tFUNCTION '%s'-> (%d)\n",FktId,Found);
    fflush(debug);
  }

  return(Found);
}
/* END FUNCTION FindFirst *****************************************************/


/* FUNCTION SetupSino2D *******************************************************/
/* eub 010626 rename SetupRef1D -> SetupSino2D for comp. with 1D setup	      */
/* 010921 eub store parameter from setup				      */
/* 041222 eub range for ExpOff increased				      */
/******************************************************************************/
int SetupSino2D( const char *curdat )
{
  static const char FktId[] = "SetupSino2D 010921";
  static const char DHeader[] = "---- SIGNAL-TO-NOISE CONTROL -----------";

  char DialogStr[STRING_MAXLENGTH],Answer[STRING_MAXLENGTH];
  int TempInt;
  int Expno2;
  float SINOMin = 0.;
  int ExpOff = 0;
  int DoDialog = 0;

  if (debug)
  {
    if( DBL >= 1 )
      fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* Get starting values from dataset */
  FETCHPAR("CNST 26",&SINOMin);
  FETCHPAR("L 20",&ExpOff);
  Expno2 = expno - ExpOff;
  if(DBL >= 1)
    fprintf(debug,"Start CNST26 %.1f L20 %d\n",SINOMin,Expno2);

  DoDialog = 0;
  do
  {
    if( DoDialog > 0 )
    {
      /* Do not request values in the 1st loop */

      if( SINOMin == 0. )
      { strcpy(Answer,"no"); }
      else
      { sprintf(Answer,"yes"); }

      /* Ask user */
      GETSTRING("Signal-to-noise control [no/yes] ",Answer);
      if( Answer[0] == 'n' )
      {
	SINOMin = 0.;
      }
      else
      {
	sprintf(Answer,"%.1f %d",SINOMin,Expno2);
	GETSTRING("SINO <min>  Reference1D <expno> ",Answer);

	/* Check answer */
	TempInt = sscanf(Answer,"%f %d ", &SINOMin, &Expno2);
	ExpOff = expno - Expno2;

	if( ExpOff<1 || ExpOff >= expno )
	{
	  ExpOff = 1;
	}
	Expno2 = expno - ExpOff;

	if( SINOMin <= 0 )
	{
	  SINOMin = 0.;
	}
      }
    }
    /* for the next loop activate the dialog */
    DoDialog++;

    /* Build the Dialog */
    if( SINOMin == 0 )
    {
      sprintf(DialogStr
	,"%s\nRun experiment '%s' %d\nwithout checking Reference1D"
	,DHeader,name,expno);
    }
    else
    {
      sprintf(DialogStr
	,"%s\nRun experiment '%s' %d\nif Reference1D '%s' %d\nshows Signal-to-Noise > %4.1f:1"
	,DHeader,name,expno,name,Expno2,SINOMin);
    }

  }while( Proc_err(ERROPT_AK_CAN,DialogStr) );

  if( DoDialog>1 )
  {
    STOREPAR("CNST 26",SINOMin);
    STOREPAR("L 20",ExpOff);
    if(DBL >= 1)
      fprintf(debug,"Set CNST26 %.1f L20 %d\n",SINOMin,ExpOff);
  }

  /* End of the program */
  if(debug)
  {
    (void)fprintf(debug,"<FUNCTION %s: SINOMin %.1f EXPNO %d\n"
      ,FktId,SINOMin,(int)(expno-ExpOff));
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION SetupSino2D ***************************************************/

/* FUNCTION SetupSino2D2*******************************************************/
/* eub 070115 Created from SetupSino2D					      */
/******************************************************************************/
int SetupSino2D2( const char *curdat )
{
  static const char FktId[] = "SetupSino2D2 070115";
  static const char DHeader[] = "---- SIGNAL-TO-NOISE CONTROL -----------";

  char	  DialogStr[STRING_MAXLENGTH],Answer[STRING_MAXLENGTH];
  int	  Expno2;
  float	  SINOMin = 0.;
  int	  ExpOff = 0;
  int	  DoDialog = 0;
  int	  NSSet = 32; /* total NS */
  int	  NSMin = 8; /* minimum NS */
  float	  SIGF1Set,SIGF2Set;

  if (debug)
  {
    if( DBL >= 1 )
      fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* Get starting values from dataset */
  FETCHPAR("NS",&NSSet);
  FETCHPAR("L 31",&NSMin);
  if( NSMin > NSSet )
    NSMin = 1;

  FETCHPAR("CNST 26",&SINOMin);
  FETCHPAR("SIGF1", &SIGF1Set);
  FETCHPAR("SIGF2", &SIGF2Set);

  FETCHPAR("L 20",&ExpOff);
  Expno2 = expno - ExpOff;
  if(DBL >= 1)
    fprintf(debug
    ,"Start with\nExpnoOff(L20)%d; NS %d; NSMin(L31) %d; SinoMin(CNST26) %.1f \n"
    ,ExpOff,NSSet,NSMin,SINOMin);

  DoDialog = 0;
  do
  {
    if( DoDialog > 0 )
    {
      /* Do not request values in the 1st loop */

      if( SINOMin == 0. )
      { strcpy(Answer,"no"); }
      else
      { sprintf(Answer,"yes"); }

      /* Ask user */
      GETSTRING("Signal-to-noise control [no/yes] ",Answer);
      if( Answer[0] == 'n' )
      {
	SINOMin = 0.;
      }
      else
      {
	GETINT("Experiment number of the Reference1D ",Expno2);
	if( Expno2>=expno || Expno2<1 )
	  Expno2 = expno - 1;
	ExpOff = expno - Expno2;

	sprintf(Answer,"Enter MAX. NS [1-4096] ");
	GETINT(Answer,NSSet);
	if( NSSet<1 || NSSet>4096 )
	  NSSet = 8;

	if( SINOMin == 0. )
	{
	  SINOMin = 6.;
	}
	GETFLOAT("Enter requested SINO ",SINOMin);
	if( SINOMin <= 1. )
	{
	  SINOMin = 1.;
	}

	/* Signal region */
	sprintf(Answer,"%.3f %.3f",SIGF1Set,SIGF2Set);
	GETSTRING(
	  "Enter signal region [ppm]\n(NOISE region of 1D spectrum is used)"
	  ,Answer);
	(void)sscanf(Answer,"%f %f",&SIGF1Set,&SIGF2Set);


	sprintf(Answer,"Enter Min. NS (%d to %d) ",1,NSSet);
	GETINT(Answer,NSMin);
	if( NSMin<1 || NSMin>NSSet )
	  NSMin=1;
      }
    }
    /* for the next loop activate the dialog */
    DoDialog++;

    /* Build the Dialog */
    if( SINOMin == 0. )
    {
      sprintf(DialogStr
	,"%s\nRUN the experiment do NOT check Reference"
	,DHeader);
    }
    else
    {
      sprintf(DialogStr
	,"%s\nTake SINO from Reference '%s' %d\n"
	"In region %.3f - %.3fppm\n"
	"Adjust NS between %d to %d to reach SINO %4.1f:1"
	,DHeader,name,Expno2,SIGF1Set,SIGF2Set,NSMin,NSSet,SINOMin);
    }

  }while( Proc_err(ERROPT_AK_CAN,DialogStr) );

  if( DoDialog>1 )
  {
    STOREPAR("CNST 26",SINOMin);
    STOREPAR("L 20",ExpOff);
    STOREPAR("NS",NSSet);
    STOREPAR("L 31",NSMin);
    STOREPAR("SIGF1", SIGF1Set);
    STOREPAR("SIGF2", SIGF2Set);
  }

  /* End of the program */
  if(debug)
  {
    if( SINOMin == 0)
      (void)fprintf(debug
      ,"<FUNCTION %s: NO SINO control do %dNS\n",FktId,NSSet);
    else
      (void)fprintf(debug
      ,"<FUNCTION %s: Ref EXPNO %d; SINO %.1f in %.3f/%.3fppm with NS %d-%d\n"
      ,FktId,(int)(expno-ExpOff),SINOMin,SIGF1Set,SIGF2Set,NSMin,NSSet);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION SetupSino2D2 **************************************************/

/* FUNCTION SetupSino1D *******************************************************/
/* 010920 eub DS stored, Output reduced					      */
/******************************************************************************/
int SetupSino1D( const char *curdat )
{
  static const char FktId[] = "SetupSino1D 010920";
  static const char DHeader[] = "---- NS AND SIGNAL-TO-NOISE ------------";

  char	DialogStr[STRING_MAXLENGTH],Answer[STRING_MAXLENGTH];
  int	ValOk = 0;
  int	TempInt;
  int	DoDialog = 0;

  float SINOMin = 2.5;
  float SINOMax = 20.;
  int	NSMin = 16;
  int	NSMax = 512;
  int	DSSet = 8;
  float SIGF1,SIGF2,NOISF1,NOISF2;

  if (debug)
  {
    if(DBL >= 1)
      fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }


  /* Get starting values from dataset */
  FETCHPAR("CNST 27",&SINOMin);
  FETCHPAR("SINO",&SINOMax);
  FETCHPAR("L 31",&NSMin);
  FETCHPAR("DS",&DSSet);
  FETCHPAR("NS",&NSMax);
  FETCHPAR("SIGF1",&SIGF1);
  FETCHPAR("SIGF2",&SIGF2);
  FETCHPAR("NOISF1",&NOISF1);
  FETCHPAR("NOISF2",&NOISF2);
  if(DBL>=1)
    fprintf(debug
    ,"Start NS %d DS %d L31 %d CNST27 %.1f SINO %.1f SIGF1 %.1f SIGF2 %.1f NOISF1 %.1f NOISF2 %.1f\n"
    ,NSMax,DSSet,NSMin,SINOMin,SINOMax,SIGF1,SIGF2,NOISF1,NOISF2);

  do
  {
    if( DoDialog == 1 )
    {
      /* ALWAYS store modified parameters, no check if values are o.k. */
      ValOk = 1;

      /* Do not request values in the 1st loop */
      if( SINOMax == 0. )
	strcpy(Answer,"no");
      else
	sprintf(Answer,"yes");

      /* Ask user */
      GETSTRING("Signal-to-noise control [no/yes] ",Answer);

      /* Ask further values */
      if( Answer[0] == 'n' || Answer[0] == 'N' )
      {
	sprintf(Answer,"%d %d",DSSet,NSMax);
	/* No signal to noise control, just ask for DS & NS */
	GETSTRING("Fixed Value for DS/NS ",Answer);
	sscanf(Answer,"%d %d",&DSSet,&NSMax);
	SINOMax = 0.;
      }
      else
      {
	/* Sino control ask all parameters */
	SINOMax = 15.;

	/* Scan numbers */
	sprintf(Answer,"%d   %d %d",DSSet,NSMin,NSMax);
	GETSTRING("DS and NS min/max ",Answer);
	TempInt = sscanf(Answer,"%d %d %d",&DSSet,&NSMin,&NSMax);

	/* Sino and sig boarders */
	sprintf(Answer,"%.1f %.3f %.3f",SINOMax,SIGF1,SIGF2);
	GETSTRING("Sino Sinoregion [x:1 ppm]",Answer);
	TempInt = sscanf(Answer,"%f %f %f",&SINOMax,&SIGF1,&SIGF2);

	/* Noise region */
	sprintf(Answer,"%.3f %.3f",NOISF1,NOISF2);
	GETSTRING("Noise region [ppm]",Answer);
	TempInt = sscanf(Answer,"%f %f",&NOISF1,&NOISF2);
      }

    }

    /* Prepare comprehensive Information */
    if( SINOMax == 0. )
    {
      sprintf(DialogStr,"%s\nDS %d  and fixed NS %d\nNo SINO control"
	,DHeader,DSSet,NSMax);
    }
    else
    {
      sprintf(DialogStr
      ,"%s\nScans    DS %d  NS %d to %d\n"
      "SINO     %5.1f : 1\nSignals  %5.1f - %5.1fppm\n"
      "Noise    %5.1f - %5.1fppm"
      ,DHeader,DSSet,NSMin,NSMax,SINOMax,SIGF1,SIGF2,NOISF1,NOISF2);
    }

    /* for the next loop activate the dialog */
    DoDialog = 1;

  }while( Proc_err(ERROPT_AK_CAN,DialogStr) );

  if( ValOk )
  {
    STOREPAR("SINO",SINOMax);
    STOREPAR("NS",NSMax);
    STOREPAR("DS",DSSet);
    STOREPAR("L 31",NSMin);
    STOREPAR("SIGF1",SIGF1);
    STOREPAR("SIGF2",SIGF2);
    STOREPAR("NOISF1",NOISF1);
    STOREPAR("NOISF2",NOISF2);
  }

  /* End of the program */
  if(debug)
  {
    fprintf(debug,
      "<FUNCTION %s: NS=%d L31=%d CNST27=%.1f SINO=%.1f SIGF1/2=%.1f %.1f NOISF1/2=%.1f %.1f\n"
      ,FktId,NSMax,NSMin,SINOMin,SINOMax,SIGF1,SIGF2,NOISF1,NOISF2);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION SetupSino1D ***************************************************/


/* FUNCTION SetupSino1D2 ******************************************************/
/* 010920 eub DS stored, Output reduced					      */
/* 041124 eub with TD0 loop, calc NS from duration			      */
/* 041222 eub ask DS,SINOMin						      */
/* 080323 eub do not reset SINO to 15					      */
/* 090115 eub NS with unit 'k' supported				      */
/******************************************************************************/
int SetupSino1D2( const char *curdat )
{
  static const char  FktId[] = "SetupSino1D 090115";
  static const char  DHeader[] = "---- DURATION OF EXPERIMENT ------------";

  char	DialogStr[STRING_MAXLENGTH],TempStr[STRING_MAXLENGTH],Answer[STRING_MAXLENGTH];
  int	ValOk = 0;
  int	TempInt;
  int	DoDialog = 0;
  float TempFloat;

  float SINOMin = 2.5;
  float SINOMax = 20.;
  int	NSMin = 16;
  int	NSMax = 0;
  int		NSInc = 8;
  int	  TD0Set = 1;
  int	DSSet = 8;
  float SIGF1,SIGF2,NOISF1,NOISF2;
  double	TimeRes = 0.;

  if (debug)
  {
    if(DBL >= 1)
      fprintf(debug,"/START\tFunction '%s'\n",FktId);
    fflush(debug);
  }


  /* Get starting values from dataset */
  FETCHPAR("CNST 28",&SINOMin);
  FETCHPAR("SINO",&SINOMax);
  FETCHPAR("L 31",&NSMin);
  FETCHPAR("DS",&DSSet);
  FETCHPAR("NS",&NSInc);
  FETCHPAR("TD0",&TD0Set);
  NSMax = TD0Set * NSInc;
  FETCHPAR("SIGF1",&SIGF1);
  FETCHPAR("SIGF2",&SIGF2);
  FETCHPAR("NOISF1",&NOISF1);
  FETCHPAR("NOISF2",&NOISF2);

  /* TimeRes = Timeresolution per scan as double value */
  (void)TimePerScan( curdat, &TimeRes );

  if(DBL>0)
  {
    fprintf(debug
      ,"Start NS=%d NSInc=%d TD0=%d DS=%d %.1fsec/scan L31 %d CNST28 %.1f SINO %.1f SIGF1 %.1f SIGF2 %.1f NOISF1 %.1f NOISF2 %.1f\n"
      ,NSMax,NSInc,TD0Set,DSSet,TimeRes,NSMin,SINOMin,SINOMax,SIGF1,SIGF2,NOISF1,NOISF2);
    fflush(debug);
  }

  do
  {
    if( DoDialog == 1 )
    {
      /* ALWAYS store modified parameters, no check if values are o.k. */
      ValOk = 1;

      /* Do not request values in the 1st loop */
      if( SINOMax == 0. )
	strcpy(Answer,"no");
      else
	sprintf(Answer,"yes");

      /* Ask user */
      GETSTRING("Signal-to-noise control [no/yes] ",Answer);

      /* Ask further values */
      if( Answer[0] == 'n' || Answer[0] == 'N' )
      {
	sprintf(Answer,"%d",NSMax);
	/* No signal to noise control, just ask for DS & NS */
	GETINT("Enter DS",DSSet);
	GETSTRING("NS or duration[NS/min]",Answer);
	if( sscanf(Answer,"%f %s",&TempFloat,TempStr) == 2 )
	{
	  if( TempStr[0] == 'm' )
	  {
	    NSMax = 8 * (int)((TempFloat*60. - (double)DSSet * TimeRes)/(8. * TimeRes));
	  }
	  if( TempStr[0] == 'k' )
	  {
	    NSMax = (int)TempFloat*1024;
	  }
	}
	else
	{
	  NSMax = (int)TempFloat;
	}
	if( NSMax < 1 )
	  NSMax = 1;

	NSInc = NSMax;
	SINOMax = 0.;
      }
      else
      {
	/* Sino control ask all parameters */
	if(SINOMax == 0. )
	  SINOMax = 15.;

	/* Scan numbers */
	GETINT("Enter DS",DSSet);
	GETINT("Acquire NS in steps of",NSInc);
	if(NSMax < NSInc)
	  NSMax = NSInc;

	/* No signal to noise control, just ask for DS & NS */
	sprintf(Answer,"%d",NSMax);
	GETSTRING("Max. NS or duration[NS/min]",Answer);
	if( sscanf(Answer,"%f %s",&TempFloat,TempStr) == 2 && TempStr[0] == 'm' )
	{
	  NSMax = 8 * (int)((TempFloat*60. - (double)DSSet * TimeRes)/(8. * TimeRes));
	}
	else
	{
	  NSMax = (int)TempFloat;
	}
	if( NSMax < 1 )
	  NSMax = 1;

	/* Scan numbers */
	NSMin = NSInc;
	GETINT("First Sino Check after NS",NSMin);

	/* Sino and sig boarders */
	sprintf(Answer,"%.1f %.1f",SINOMax,SINOMin);
	GETSTRING("Requested SINO and min. value",Answer);
	TempInt = sscanf(Answer,"%f %f",&SINOMax,&SINOMin);
	sprintf(Answer,"%.3f %.3f",SIGF1,SIGF2);
	GETSTRING("Sino Sinoregion [ppm ppm]",Answer);
	TempInt = sscanf(Answer,"%f %f",&SIGF1,&SIGF2);

	/* Noise region */
	sprintf(Answer,"%.3f %.3f",NOISF1,NOISF2);
	GETSTRING("Noise region [ppm]",Answer);
	TempInt = sscanf(Answer,"%f %f",&NOISF1,&NOISF2);
      }
    }

    /* Check for consistency */
    if( NSInc > NSMax )
      NSInc = NSMax;

    TD0Set = (int)((double)NSMax / (double)NSInc);
    NSMax = NSInc * TD0Set;

    if( NSMin < NSInc || NSMin > NSMax )
      NSMin = NSInc;

    /* Prepare comprehensive Information */
    if( SINOMax == 0. )
    {
      sprintf(DialogStr,"%s\nExperiment time %.1fmin with DS %d NS %d\nNo SINO control"
	,DHeader,( TimeRes * (DSSet+NSMax))/60.,DSSet,NSMax);
    }
    else
    {
      sprintf(DialogStr
	,"%s\nMax. duration %.1fmin\nDS %d, NS %d -> %d (=%d * %d)\nSignal %5.1f:1 @ %5.1f - %5.1fppm\nNoise    %5.1f - %5.1fppm"
	,DHeader,( TimeRes * (DSSet+NSMax))/60.,DSSet,NSMin,NSMax,TD0Set,NSInc,SINOMax,SIGF1,SIGF2,NOISF1,NOISF2);
    }

    /* for the next loop activate the dialog */
    DoDialog = 1;

  }while( Proc_err(ERROPT_AK_CAN,DialogStr) );

  if( ValOk )
  {
    (void)AUMessage("\nSave modified parameters\n");
    STOREPAR("SINO",SINOMax);
    STOREPAR("CNST 28",SINOMin);
    STOREPAR("DS",DSSet);
    STOREPAR("NS",NSInc);
    STOREPAR("TD0",TD0Set);
    STOREPAR("L 31",NSMin);
    STOREPAR("SIGF1",SIGF1);
    STOREPAR("SIGF2",SIGF2);
    STOREPAR("NOISF1",NOISF1);
    STOREPAR("NOISF2",NOISF2);
  }

  /* End of the program */
  if(debug)
  {
    fprintf(debug,
      "\nRESULT\tNS=(1-%d)*%d=%d->%d SINO=%.1f->%.1f SIG=%.1f/%.1f NOISE=%.1f/%.1f\n\\END\tFUNCTION %s\n"
      ,TD0Set,NSInc,NSMin,NSMax,SINOMin,SINOMax,SIGF1,SIGF2,NOISF1,NOISF2,FktId);
    fflush(debug);
  }
  return(0);
}
/* END FUNCTION SetupSino1D2 **************************************************/



int SetupMessage( const char *curdat )
{
  if( Proc_err(ERROPT_AK_CAN,
    "<HTML><TABLE WIDTH=350 VALIGN=TOP>"
    "<TR>"
    "<TD COLSPAN=2><H2>Extended Automation Parameters</H2>"
    "Setup of parameters for automated data acquisition with "
    "<B>xaua</B> and/or <B>ICONNMR</B>.</TD>"
    "</TR><TR>"
    "<TD ALIGN=RIGHT><B>OK:</B></TD><TD WIDTH=1>Run setup dialog.</TD>"
    "</TR><TR>"
    "<TD ALIGN=RIGHT><B>CANCEL:</B></TD><TD WIDTH=1>Abort setup.</TD>"
    "</TR></TABLE></HTML>")
    )
    return(1);
  else
    return(0);
}

int SetupMessage2( const char *curdat )
{
  if( Proc_err(ERROPT_AK_CAN,
    "<HTML><TABLE WIDTH=350 VALIGN=TOP>"
    "<TR>"
    "<TD COLSPAN=2><H2>Extended Automation Parameters - Details</H2>"
    "The following dialog will request <B>special</B> automation parameters. "
    "These parameters typically need to be changed for special purposes only. "
    "Check the LC-NMR manual for details.</TD>"
    "</TR><TR>"
    "<TD ALIGN=RIGHT><B>OK:</B></TD><TD WIDTH=1>Leave special parameters unchanged.</TD>"
    "</TR><TR>"
    "<TD ALIGN=RIGHT><B>CANCEL:</B></TD><TD WIDTH=1>Run setup for special parameters.</TD>"
    "</TR></TABLE></HTML>")
    )
    return(1);
  else
    return(0);
}


/* FUNCTION SetupDetRG 090117 *************************************************/
/* Setup the acquisition parameters with the user			      */
/* Preparation experiment separately					      */
/* eub 030303 DE changes included					      */
/* 040308 obsolete variables deleted					      */
/* 041222 Automatic DE adjustment included				      */
/* 090206 eub Fixed RG through CNST29=0, value for RG in RG		      */
/*	      fix. RG with neg. CNST29 automatically converted		      */
/******************************************************************************/
int SetupDetRG( const char *curdat )
{
  static const char FktId[] = "SetupDetRG 090117";
  static const char DHeader[] = "------ RECEIVERGAIN DETERMINATION ------";
  char DialogStr[STRING_MAXLENGTH];

  int	  Change = 0;
  char	  Answer[PATH_MAX],TempStr[PATH_MAX];
  char	  StatusStr[PATH_MAX];

  float   RGCtrl = 0.75;
  float   DESet = 0.;	  /* Original DE */
  float   DEMax = 10000.; /* Max allowed DE */
  float   DERg = 0.;	  /* defined in D31 */
  float   RGSet = 1.;	  /* defined in RG */


  /* Get starting values from dataset */
  FETCHPAR("CNST 29",&RGCtrl);
  FETCHPAR("RG",&RGSet);
  FETCHPAR("DE",&DESet);
  FETCHPAR("D 31",&DERg);
  DERg = DERg * 1000000.f;

  /* Check for previous version RG=-CNST29 and convert */
  if( RGCtrl<0. )
  {
    RGSet = -RGCtrl;
    RGCtrl = 0.;
  }

  do
  {
    if( Change )
    {
      /* Request Receivergain control ***********************/
      /* prepare Answer */
      if( RGCtrl != 0. )
      { sprintf(Answer,"rga %.2f ",RGCtrl); }
      else
      {	sprintf(Answer,"fixed %.0f",RGSet); }

      /* Ask user */
      GETSTRING("Use RG from [rga <korr>/fixed <rg>] ",Answer);
      (void)sscanf(Answer,"%s %f ",TempStr, &RGCtrl);

      /* Check entered values */
      if( TempStr[0] == 'r' )
      {
	if( RGCtrl <= 0. || RGCtrl >= 128. )
	  RGCtrl = 1.;
      }
      else
      {
	RGSet = RGCtrl;
	if( RGSet<1. )
	  RGSet = 1.;
	RGCtrl = 0.;
      }

      /* Request DE *******************************************/
      if( RGCtrl!=0. )
      {
	if( DERg == 0. )
	{ sprintf(Answer,"automatic"); }
	else
	{ sprintf(Answer,"use %.1f",DERg); }
	GETSTRING("DE[us] RGA [auto/use <value>]",Answer);
	sscanf(Answer,"%s%f",TempStr,&DERg);
	switch( TempStr[0] )
	{
	case 'u':
	  if( DERg<=0 || DERg>DEMax )
	    DERg = DESet;
	  break;

	case 'a':
	default:
	  DERg = 0.;
	  break;
	}
      }

    }
    Change = 1;
    strcpy(DialogStr,DHeader);

    if( RGCtrl != 0. )
    {
      /* RG determination */
      sprintf(DialogStr,"%s\nRG from RGA corrected by %.2f",DialogStr,RGCtrl);
      sprintf(StatusStr,"RG=RGA*%.2f",RGCtrl);

      /* DE Determination */
      if( DERg == 0. )
      {
	sprintf(DialogStr,"%s\nRGA automatically adjusted DE",DialogStr);
	sprintf(StatusStr,"%s  DE=auto.",StatusStr);
      }
      else
      {
	sprintf(DialogStr,"%s\nRGA with DE %.1fus",DialogStr,DERg);
	sprintf(StatusStr,"%s  DE=%.1fus",StatusStr,DERg);
      }
    }
    else
    {
      sprintf(DialogStr,"%s\nRG fixed at %.0f.0",DialogStr,RGSet);
      sprintf(StatusStr,"RG=%.0f.0 fixed",RGSet);
    }

  }
  while( Proc_err(ERROPT_AK_CAN,DialogStr) );

  if ( Change == 1 )
  {
    STOREPAR("RG",RGSet);
    STOREPAR("CNST 29",RGCtrl);
    STOREPAR("D 31",DERg / 1000000.);
    if(DBL >= 1)
    { (void)fprintf(debug,"STORE RG %.0f CNST29 %.2f  D31 %.6f\n"
    ,RGSet,RGCtrl,DERg / 1000000.); }
  }

  if(debug)
  {
    (void)fprintf(debug,"<FUNCTION %s: %s\n",FktId,StatusStr);
    fflush(debug);
  }

  return 0;
}
/* END FUNCTION SetupDetRG ****************************************************/


/* FUNCTION SetupPrep 010227 **************************************************/
/* 010921 eub DialogLoop changed, store params changed			      */
/* 011010 eub DS NOT from L26						      */
/* 090804 eub Stringlength USERA1					      */
/******************************************************************************/
int SetupPrep( const char *curdat )
{
  static const char FktId[] = "SetupPrep 090804";
  static const char DHeader[] =
    "-- PREPARATION EXPERIMENT --------------\n(Parameter for solvent search spectrum)";

  char  DialogStr[STRING_MAXLENGTH];

  int   DoDialog = 0;
  int	TempInt;
  char	Answer[PATH_MAX],TempStr[PATH_MAX];
  char	PPPrep[64],USERA1[STRING_MAXLENGTH];

  int	NSPrep = 4;
  int	DSPrep = 8;
  double RGPrep = 4.;

  /* Get starting values from dataset */
  FETCHPAR("L 28",&TempInt);
  RGPrep = TempInt;
  FETCHPAR("L 25",&NSPrep);
  FETCHPAR("L 26",&DSPrep);
  FETCHPAR("PULPROG",PPPrep);
  FETCHPAR("USERA1",USERA1);
  if( KeyWords_2( USERA1, 0, "f", "zg", NULL, "") )
    strcpy(PPPrep,"zg");

  DoDialog = 0;
  do
  {
    if( DoDialog )
    {
      /* Number of scans and pulsprogram */
      /* sprintf(Answer,"%d %d",DSPrep,NSPrep);
      GETSTRING("Scans for prep. experiment [DS NS] ",Answer);
      TempInt = sscanf(Answer,"%d %d ",&DSPrep, &NSPrep); */
      sprintf(Answer,"%d",NSPrep);
      GETSTRING("Scans for prep. experiment [NS] ",Answer);
      TempInt = sscanf(Answer,"%d ",&NSPrep);

      /* RG setting */
      if( RGPrep == 0. )
	strcpy(Answer,"rga");
      else
	sprintf(Answer,"fixed %.0f",RGPrep);

      GETSTRING("RG determination [rga/fixed <rg>] ",Answer);
      TempInt = sscanf(Answer,"%s %lf ",TempStr, &RGPrep);
      if( TempStr[0] == 'r' )
	RGPrep = 0.;
      else
      {
	if( TempInt == 1 )
	  RGPrep = 4.;
      }
    }
    DoDialog++;

    /* Check entered values */
    if( DSPrep <= 0 )
      DSPrep = 0;
    if( NSPrep < 1 )
      NSPrep = 1;

    /* Prepare Message */
    /* sprintf(DialogStr,"%s\nPulsprogram '%s'\nScans DS %d  NS %d"
    ,DHeader,PPPrep,DSPrep,NSPrep); */
    sprintf(DialogStr,"%s\nPulsprogram '%s'\nScans NS %d"
      ,DHeader,PPPrep,NSPrep);
    if( RGPrep == 0. )
      sprintf(DialogStr,"%s\nRG from RGA",DialogStr);
    else
      sprintf(DialogStr,"%s\nFixed RG of %.0f",DialogStr,RGPrep);

  }
  while( Proc_err(ERROPT_AK_CAN,DialogStr) );

  if ( DoDialog > 1 )
  {
    STOREPAR("L 28",(int)(RGPrep));
    STOREPAR("L 25",NSPrep);
    STOREPAR("L 26",DSPrep);
  }

  if(debug)
  {
    (void)fprintf(debug
      ,"<FUNCTION %s: DSPrep %d NSPrep %d RGPrep %.1f\n"
      ,FktId,DSPrep,NSPrep,RGPrep);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION SetupPrep *****************************************************/



/* FUNCTION SetupAcqu1D 001220 ************************************************/
/* Setup the acquisition parameters with the user			      */
/* 030325 eub FETCHPAR of RGCtrl after setup				      */
/* 090115 eub setup offres removed					      */
/******************************************************************************/
int SetupAcqu1D( const char *curdat )
{
  static const char FktId[] = "SetupAcqu1D 090115";
  static const char DHeader[] = "----- BASIC EXPERIMENT PARAMETERS ------";

  char	 DialogStr[STRING_MAXLENGTH],Answer[STRING_MAXLENGTH];
  int	 TempInt;
  int	 DoDialog = 0;

  double O1Set = 0.;
  double BF1Set = 500.13;
  float  SRSet	= 0.;
  double SWSet	= 10.;
  int	 NSSet = 1;
  int	 DSSet = 0;
  float  D1Set = 1.;
  float  From,To;
  char	 USERA1[STRING_MAXLENGTH];
  int	 SolvAnzMax = 0;
  int	 OffRes = 0;

  if (debug)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* Get starting values from dataset */
  FETCHPAR("O1",&O1Set);
  FETCHPAR("BF1",&BF1Set);
  FETCHPAR("SR",&SRSet);
  FETCHPAR("SW",&SWSet);
  From = (float)((O1Set-SRSet)/BF1Set+SWSet/2.);
  To   = (float)((O1Set-SRSet)/BF1Set-SWSet/2.);
  FETCHPAR("D 1",&D1Set);

  FETCHPAR("L 30",&SolvAnzMax);
  FETCHPAR("USERA1",USERA1);
  OffRes = KeyWords_2( USERA1, 0, "f", KEYW_OFFRES, NULL, "");

  if(DBL>=1)
    fprintf(debug,"Parameters O1 %.1fHz SW %fppm NS %d DS %d D1 %.1fsec\n"
    ,O1Set,SWSet,NSSet,DSSet,D1Set);

  do
  {
    if( DoDialog == 1 )
    {

      /* SW, O1 only if it is not changed */
      if( SolvAnzMax==0 || (SolvAnzMax>0 && OffRes) )
      {
	sprintf(Answer,"%.3f %.3f",From,To);
	GETSTRING("Spectrum range from to [ppm] ",Answer);

	/* Check answer */
	TempInt = sscanf(Answer,"%f %f", &From, &To);
	if( TempInt == 2 && From > To && From != To )
	{
	  /* Accept answer and calculate dependencies */
	  SWSet = (double)(From-To);
	  O1Set = (double)((From+To)/2.*BF1Set+SRSet);
	}
	else
	{
	  /* Reset to last valid values */
	  From = (float)((O1Set-SRSet)/BF1Set+SWSet/2.);
	  To   = (float)((O1Set-SRSet)/BF1Set-SWSet/2.);
	}
      }
      else
      {
	GETFLOAT(
	  "Spectral window\n\n"
	  "O1 is changed to is biggest solvent signal. Choose the spectral\n"
	  "window wide enough to cover the desired spectral region\n"
	  "Define SW in [ppm]"
	  ,SWSet);
      }

      /* Ask user */
      GETFLOAT("Relaxation D1 ",D1Set);
    }


    /* Build the Dialog */
    if( SolvAnzMax==0 || (SolvAnzMax>0 && OffRes) )
    {
      sprintf(DialogStr
	,"%s\nSpectrum Range %.1f to %.1fppm\n(SW %.1fppm O1P %.3fppm)"
	,DHeader,From,To,SWSet,(O1Set-SRSet)/BF1Set);
    }
    else
    {
      sprintf(DialogStr
	,"%s\nSW %.1fppm\nSpectrum borders depend on position for O1"
	,DHeader,SWSet);
    }

    sprintf(DialogStr,"%s\nRelaxation D1 %.1fsec",DialogStr,D1Set);


    /* for the next loop activate the dialog */
    DoDialog = 1;

  }while( Proc_err(ERROPT_AK_CAN,DialogStr) );

  STOREPAR("USERA1",USERA1);
  STOREPAR("SW",SWSet);
  STOREPAR("O1",O1Set);
  STOREPAR("D 1",D1Set);
  if(debug)
    fprintf(debug,
    "Save O1 %.1fHz SW %.3fppm D1 %.1fsec\n",O1Set,SWSet,D1Set);

  /* End of the program */
  if(debug)
  {
    (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION SetupAcqu1D ***************************************************/

/* FUNCTION SetupWET 001105 ***************************************************/
/* 0908078 eub Use -dBW							      */
/******************************************************************************/
int SetupWET( const char *curdat )
{
  static const char FktId[] = "SetupWET 100203";
  static const char DHeader[] = "------- WET SOLVENT SUPPRESSION --------";

  int	TempInt;
  char	DialogStr[STRING_MAXLENGTH],Answer[STRING_MAXLENGTH];
  int	ValOk = 0;

  float RefL = 20.;
  float RefPL = 1000.;
  char	RefN[PATH_MAX] = "Sinc1.1000";

  float GrdRecL = 300.;
  float GrdL = 1.;
  float GrdPL = 80.;
  char	GrdN[PATH_MAX] = "SINE.100";

  int	DoDialog = 0;

  float KorrPl = 0.;

  if (debug)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* Get starting values from dataset */
  FETCHPAR("P 11",&RefL);
  RefL = RefL * 0.001f;
  FETCHPAR("SPdB 2",&RefPL);
  FETCHPAR("SPNAM2",RefN);

  FETCHPAR("P 16",&GrdL);
  GrdL = GrdL * 0.001f;
  FETCHPAR("D 16",&GrdRecL);
  GrdRecL = GrdRecL * 1e6f;
  STOREPAR("GPNAM1",GrdN);
  FETCHPAR("GPZ 1",&GrdPL);

  FETCHPAR("SPdB 15",&KorrPl);
  if( KorrPl > 6. ) KorrPl = 0.;

  /* Check if ALL parameters are o.k. */
  do{

    if( DoDialog )
    {
      ValOk = 1;

      /* Reference 90deg pulse */
      sprintf(Answer,"%s %.1f %.2f",RefN,RefL,RefPL);
      GETSTRING("Ref. pulse (name lenght[us] power[-dBW]) ",Answer);
      TempInt = sscanf(Answer,"%s %f %f",RefN, &RefL,&RefPL);

      /* Correction Value for last WET pulse */
      GETFLOAT("Corr. Value for last WET pulse [-dBW]",KorrPl);
      if( KorrPl > 6. || KorrPl < -6. )
	KorrPl = 0.;

      /* Gradient Parameters */
      sprintf(Answer,"%s %.1f %.0f",GrdN,GrdL,GrdPL);
      GETSTRING("Grad. pulse (name lenght[us] power[%%])",Answer);
      GETFLOAT("Recovery delay [usec] ",GrdRecL);
      TempInt = sscanf(Answer,"%s %f %f",GrdN,&GrdL,&GrdPL);
    }

    DoDialog = 1;

    /* Comprehensive Message */
    sprintf(DialogStr
    ,"%s\nSelective Pulse\n%.1fm '%s' %.1f-dBW  Corr %.1f-dBW\n\
    Gradient Pulse\n%.1fm '%s' %.0f%%  Rec %.1fu"
    ,DHeader,RefL,RefN,RefPL,KorrPl,GrdL,GrdN,GrdPL,GrdRecL);

  }while(Proc_err(ERROPT_AK_CAN,"%s",DialogStr));


  if ( ValOk == 1 )
  {
    STOREPAR("P 11",RefL*1000.);
    STOREPAR("SPdB 2",RefPL);
    STOREPAR("SPNAM2",RefN);
    STOREPAR("SPdB 15",KorrPl);
    (void)WetPlSet( curdat, RefN, RefPL, 0., KorrPl );

    STOREPAR("P 16",GrdL * 1e3);
    STOREPAR("D 16",GrdRecL * 1e-6);
    STOREPAR("GPNAM1",GrdN);
    STOREPAR("GPNAM2",GrdN);
    STOREPAR("GPNAM3",GrdN);
    STOREPAR("GPNAM4",GrdN);
    STOREPAR("GPZ 1",GrdPL);
    STOREPAR("GPZ 2",GrdPL/2);
    STOREPAR("GPZ 3",GrdPL/4);
    STOREPAR("GPZ 4",GrdPL/8);
  }

  if (debug)
  {
    fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return 0;
}
/******************************************************************************/


/* FUNCTION SetupAcqu2D 010601 ************************************************/
/* Setup the acquisition parameters with the user			      */
/* 040308 obsolete variables deleted					      */
/******************************************************************************/
int SetupAcqu2D( const char *curdat )
{
  /* General Message for this Setupprocedure */
  Proc_err(1,"SETUP - ACQUISITION PARAMETERS");

  /* RGA for experiment */
  (void)SetupDetRG( curdat );

  /* NS and SW */
  (void)SetupAcqu1D( curdat );
  return 0;
}
/* END FUNCTION SetupAcqu2D ***************************************************/



/* FUNCTION SetupSSearch ******************************************************/
/* Creates a message into the debugfile use only for fixed text		      */
/* 010516 check if params valid, question loop changed			      */
/* 040308 eub Variables for TOPSPIN					      */
/* 040310 eub left,right border mixed					      */
/* 040310 eub max solvent number from pulsprogram list			      */
/* 090115 eub offres included, XWIN parameters removed			      */
/* 090117 eub check if suppression parameters at all are required	      */
/******************************************************************************/
int SetupSSearch( const char *curdat )
{
  static const char FktId[] = "SetupSSearch 090119";
  static const char DHeader[] = "------------ SOLVENT SEARCH ------------";

  char	TempStr[STRING_MAXLENGTH];

  double F1P,F2P;
  int	SolvAnz = 1;
  int	SolvAnzMax = 0;
  char	Dialog[STRING_MAXLENGTH],Answer[PATH_MAX];
  int	Change = 0;
  int	PSCALMode = 0;
  char	PULPROG[128],PULPROGSearch[128];
  char	OffResInfo[128] = "";
  char	SolvAnzInfo[128] = "";
  char	CmdPar[STRING_MAXLENGTH] = "";
  double  O1PSet = 0.;
  double BF1Set = 0.;
  float  SRSet	= 0.;

  if (debug)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  FETCHPAR("L 30",&SolvAnz);
  strcpy(Answer,"yes");
  if( SolvAnz == 0 )
    strcpy(Answer,"no");

  GETSTRING(
    "Determine and adjust parameters for solvent suppression?\n\n"
    "(y)es:\tActivate solvent search and define parameters\n"
    "(n)o:\tDEactivat solvent search. Use for experiments ...\n"
    "\t* withOUT solvent suppression\n"
    "\t* WITH suppression to keep parameters (O1,...)\n"
    "\t  unchanged"
    ,Answer);

  if( Answer[0] == 'n' )
  {
    STOREPAR("L 30",0);
  }
  else
  { /* Perform solvent search */

    /* Defines experiment specific number of solvents */
    /* By default L8=0, if SolvAnzMax is found it was probably not define in */
    /* the experiment and it will be ignored */
    FETCHPAR("PULPROG",PULPROG);
    /* prevent that 'lc2' is found in 'lc2pnf2' */
    (void)sprintf(PULPROGSearch,"_%s_",PULPROG);
    if( strstr(MAXSOLV_1,PULPROGSearch) != NULL ) SolvAnzMax = 1;
    if( strstr(MAXSOLV_2,PULPROGSearch) != NULL ) SolvAnzMax = 2;
    if( strstr(MAXSOLV_3,PULPROGSearch) != NULL ) SolvAnzMax = 3;
    if( strstr(MAXSOLV_n,PULPROGSearch) != NULL ) SolvAnzMax = 24;
    if( SolvAnzMax == 0 )
    {
      sprintf(SolvAnzInfo
	,"(Pulsprogram '%s' unknown\ncheck possible number of solvents)"
	,PULPROG);
    }
    else
    {
      sprintf(SolvAnzInfo
	,"(Pulsprogram supports %d - %d solvents)"
	,1,SolvAnzMax);
    }

    /* check if pulprog allows off-resonance */
    if( KeyWords_2( MAXSOLV_n, 0, "f", PULPROGSearch, NULL, "") )
    {
      sprintf(OffResInfo
	,"\nPulsprogram '%s' unknown check that off-resonance\nsuppression is possible!"
	,PULPROG);
    }

    /* Get starting values from dataset */
    FETCHPAR("USERA1",CmdPar);
    FETCHPAR("L 30",&SolvAnz);
    FETCHPAR("PSCAL",&PSCALMode);
    FETCHPAR("F1P",&F1P);
    FETCHPAR("F2P",&F2P);
    FETCHPAR("O1P",&O1PSet );
    FETCHPAR("BF1",&BF1Set);
    FETCHPAR("SR",&SRSet);
    O1PSet = O1PSet-(SRSet/BF1Set);

    do
    {
      if( Change )
      {
	/* Ask user */
	sprintf(TempStr
	  ,"Number of Solvents\n\nEnter the maximum number of solvents resonances\nyou want to search and suppress\n%s"
	  ,SolvAnzInfo);
	GETINT(TempStr,SolvAnz);

	/* Solvent region */
	GETFLOAT("Left limit for solvent search [ppm]",F1P);
	GETFLOAT("Right limit for solvent search [ppm]",F2P);

	/* check for off- or on-resonance */
	strcpy(Answer,"solvent");
	if( KeyWords_2( CmdPar, 0, "f", KEYW_OFFRES, NULL, "") )
	  strcpy(Answer,"fixed");
	sprintf(TempStr,
	  "Positioning of O1\n\n"
	  "(s)olvent:\tSet O1 on-resonance to most intens solvent\n"
	  "(f)ixed\tKeep O1 at %.3fppm and perform\n\tsuppression off-resonance%s"
	  ,O1PSet,OffResInfo);
	GETSTRING(TempStr,Answer);
	if( Answer[0]=='f' )
	{
	  (void)KeyWords_2( CmdPar, 0, "a", KEYW_OFFRES, NULL, "");
	}
	else
	{
	  (void)KeyWords_2( CmdPar, 0, "d", KEYW_OFFRES, NULL, "");
	}

      }

      if( SolvAnz < 1)
	SolvAnz = 1;

      if( SolvAnz<1 && (SolvAnz>SolvAnzMax && SolvAnzMax != 0) )
      {
	Proc_err(1
	  ,"-- WARNING -----------------------------\n"
	  "Suppression of %d solvents not possible.\n"
	  "  PULPROG '%s'\nallows max. %d frequencies\n"
	  ,SolvAnz,PULPROG,SolvAnzMax);
      }

      if( F1P <= F2P )
      { F1P = 11.; F2P = 0.; }

      if( KeyWords_2( CmdPar, 0, "f", KEYW_OFFRES, NULL, "" ) )
      {
	sprintf(Answer,"Leave O1 fixed @ %.3fppm",O1PSet);
      }
      else
      {
	strcpy(Answer,"Set O1 on resonance to biggest solvent");
      }

      /* Check if 'wet' or 'wet-yes' is included */
      if( KeyWords_2( CmdPar, 0, "f", "wet-yes", NULL, "" ) )
	(void)SetupWET( curdat );

      Change = 1;

      sprintf(Dialog
	,"%s\nSearch %d solvents\nIn region %.1f %.1fppm\n%s"
	,DHeader,SolvAnz,F1P,F2P,Answer);
    }while( Proc_err(ERROPT_AK_CAN,Dialog) );

    if ( Change == 1 )
    {
      STOREPAR("USERA1",CmdPar);
      STOREPAR("L 30",SolvAnz);
      STOREPAR("F1P",F1P);
      STOREPAR("F2P",F2P);
      if( DBL>0 )
	fprintf(debug
	,"Save parameters USERA1='%s' L30=%d, F1P=%.3f, F2P=%.3f\n"
	,CmdPar,SolvAnz,F1P,F2P);
    }
  }
  /* End of the program no Proc_err, only subroutine */
  if(debug)
  {
    (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION SetupSSearch **************************************************/


/* FUNCTION ReadPeakList ******************************************************/
/* 001003 char FileP in header as pointer */
/* 010602 debug changed */
int ReadPeakList
( char *PeakListFP, int PkAnzMax, double *Frq, double *Hwb, double *PrzGauss )
{
  static const char FktId[] = "ReadPeakList 010602";

  char TempStr[STRING_MAXLENGTH];

  int i;
  int PkAnz = 0;
  int PkNr;

  FILE *PeakListF;

  if (debug)
  {
    if(DBL>=0)
      (void)fprintf(debug
      ,"/START\tFUNCTION '%s'\nRead from '%s'",FktId,PeakListFP);
    else
      (void)fprintf(debug,"<FUNCTION '%s':",FktId);
    fflush(debug);
  }

  /* Open Peaklist */
  PeakListF=fopen(PeakListFP,"r");
  if ( PeakListF==NULL )
  {
    if (debug) (void)fprintf(debug,"ERROR opening '%s'\n",PeakListFP);
    return(-1);
  }

  /* Read FileHeader */
  if (DBL >= 2)
    fprintf(debug,"Read File header\n");
  for ( i=1; i <= 2; i++ )
  {
    fgets(TempStr,STRING_MAXLENGTH-1,PeakListF);
    if (DBL >= 3)
      fprintf(debug,"%d: %s",i,TempStr);
  }

  /* Read peak data into ARRAY */
  if (DBL >= 2)
    (void)fprintf(debug,"Read peak data\n");
  for (PkNr = 0; PkNr < PkAnzMax; PkNr++)
  {
    if( fscanf(PeakListF,"%lf %lf %lf"
      ,&*(Frq+PkNr),&*(Hwb+PkNr),&*(PrzGauss+PkNr)
      ) < 3)
    {
      /* End of File reached */
      break;
    }
    else
    {
      /* Peak successfully read */
      PkAnz=PkNr+1;

      if (DBL >= 2)
      {
	(void)fprintf(debug,"%d: %.3f %.2f %.1f\n"
	  ,PkNr,*(Frq+PkNr),*(Hwb+PkNr),*(PrzGauss+PkNr) );
      }
    }
  }

  /* Close peakfile */
  (void)fclose(PeakListF);

  if (debug)
  {
    if(DBL>=0)
      (void)fprintf(debug
      ," Found %d peaks\n\\END\tFUNCTION '%s'\n",PkAnz,FktId);
    else
      (void)fprintf(debug," read %d peaks\n",PkAnz);
    fflush(debug);
  }

  return(PkAnz);
}
/* END FUNCTION ReadPeakList **************************************************/


/* FUNCTION WritePeakList *****************************************************/
/* 001003 char FileP in header as pointer				      */
/* 050818 file write with "wt"						      */
/******************************************************************************/
int WritePeakList
( char *PeakListFP, int FrqAnz, double *Frq, double *Hwb, double *PrzGauss )
{
  static const char FktId[] = "WritePeakList 050818";

  char TempStr[STRING_MAXLENGTH];

  int FrqNr;
  FILE *PeakFileF;

  if (debug)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    if (DBL >= 2)
      fprintf(debug,"%d peaks",FrqAnz);
    for (FrqNr = 0; FrqNr < FrqAnz; FrqNr++)
    {
      (void)fprintf(debug," %.3f",Frq[FrqNr] );
    }
    fprintf(debug,"ppm\n");
    if (DBL >= 1)
      fprintf(debug,"to '%s'\n",PeakListFP);
    fflush(debug);
  }


  /* Open peakfile for writing */
  PeakFileF=fopen(PeakListFP,"wt");
  if ( PeakFileF==NULL )
  {
    if (debug)
      (void)fprintf(debug,"ERROR opening '%s'\n",PeakListFP);

    return(-1);
  }

  /* Create FileHeader */
  (void)sprintf(TempStr,"H\n#frequency    half width   gauss/100.\n");
  (void)fprintf(PeakFileF,TempStr);
  fflush(PeakFileF);
  if(DBL >= 3)
    (void)fprintf(debug,"Write header\n%s",TempStr);
  strcpy(TempStr,"");

  /* Write entries from ARRAY starting with Frq[0]! */
  for (FrqNr = 0; FrqNr < FrqAnz; FrqNr++)
  {
    (void)sprintf(TempStr,"%.3f   %.2f   %.1f\n"
      ,Frq[FrqNr],Hwb[FrqNr],PrzGauss[FrqNr] );
    (void)fprintf(PeakFileF,TempStr);

    if (DBL >= 3)
    {
      (void)fprintf(debug,TempStr);
    }
  }

  /* Close peakfile */
  (void)fflush(PeakFileF);
  (void)fclose(PeakFileF);


  if (debug)
  {
    fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION WritePeakList *************************************************/


/* FUNCTION FilterList ********************************************************/
/* Reduces the List to the entries which are whithin Border		      */
/* The list must be sorted in decending order				      */
/******************************************************************************/
int FilterList
( int ListItm, double *List, double *RList, int *Inx, double *Reg, int RegAnz, int Cond  )
{
  static const char FktId[] = "FilterList 001128";

  int	 TempInt;

  int ListNr;
  int ListNrLast = 0;
  int RegNr = 0;
  int Inside;

  if(debug)
  {
    if(DBL > 0)
    {
      fprintf(debug,"/START\tFUNCTION %s\n",FktId);
      if(DBL >= 3)
      {
	fprintf(debug,"\nInput values\n");
	for(TempInt=0; TempInt<ListItm; TempInt++)
	  fprintf(debug,"(%3d) %.3f\n",TempInt,*(List+TempInt) );
      }

      if(DBL >= 2)
      {
	fprintf(debug,"\n%d Include region(s)\n",RegAnz);
	for(TempInt=0; TempInt<RegAnz; TempInt++)
	  fprintf(debug,"#%3d %.3f %.3f\n",TempInt,*(Reg+2*TempInt),*(Reg+2*TempInt+1) );
      }
    }
    else
    {
      fprintf(debug,"<FUNCTION '%s': %d values into %d regions\n"
	,FktId,ListItm,RegAnz);
    }
    fflush(debug);
  }

  for( ListNr = 0; ListNr < ListItm; ListNr++ )
  {
    /* for each entry in the list */
    Inside = 0;
    if( DBL >= 3 )
      fprintf(debug,"(%3d) %.3f ",ListNr,*(List+ListNr));

    /* for each region, check if inside/outside */
    for( RegNr=0; RegNr < RegAnz; RegNr++ )
    {
      if( (*(List+ListNr) <= *(Reg+2*RegNr)) && (*(List+ListNr) >= *(Reg+2*RegNr+1)) )
      {
	if( DBL >= 3 )
	  fprintf(debug," ->#%d!",RegNr);
	Inside = 1;
      }
      else
      {
	/* break; */
	if( DBL >= 3 )
	  fprintf(debug,"  [#%d]",RegNr);
      }
    }
    if( Inside == Cond )
    {
      if( DBL >= 3 )
	fprintf(debug," = entry nr. %3d\n",ListNrLast);
      if( RList != NULL )
      {
	*(RList+ListNrLast) = *(List+ListNr);
      }
      else
      {
	*(Inx+ListNrLast) = ListNr;
      }
      ListNrLast++;
    }
    else
    {
      if( DBL >= 3 )
	fprintf(debug," = not used\n");
    }
  }
  if (debug)
  {
    fprintf(debug," List with %d entries created\n",ListNrLast);
    fprintf(debug,"\\END\tFUNCTION %s\n",FktId);
    fflush(debug);
  }
  return(ListNrLast);
}
/* END FUNCTION FilterList ****************************************************/


/* FUNCTION SortDouble ********************************************************/
/* Creates 'Inx' which contains pointers to the 'Val' in descending order     */
/* if Inx == NULL list itself is sorted					      */
/* 001001 initialize 'Inx' in any case ( also with 'Entries' = 1)	      */
/******************************************************************************/
int SortDouble( int Entries, int *Inx, double *Val )
{
  static const char FktId[] = "SortDouble 001009";

  double TempDouble;
  int	 TempInt;

  int i;
  int Exchanged;
  int IterNr = 0;
  int IterNrMax = 1000;


  if(debug)
  {
    if(DBL > 0)
    {
      if( Inx == NULL )
	fprintf(debug,"/START\tFUNCTION '%s': %d entries, sort list\n"
	,FktId,Entries);
      else
	fprintf(debug,"/START\tFUNCTION '%s': %d entries, sort index\n"
	,FktId,Entries);

      if(DBL >= 4)
      {
	fprintf(debug,"\nInput values\n");
	for(i=0; i<Entries; i++)
	  fprintf(debug,"%3d %f\n",i,*(Val+i) );
      }
    }
    else
    {
      fprintf(debug,"<FUNCTION '%s': %d entries in ",FktId,Entries);
    }
    fflush(debug);
  }

  /* initialize Inx even with 1 entry */
  if (Inx != NULL )
    for ( i=0; i < Entries; i++ )
    {
      *(Inx + i) = i;
    }

    if ( Entries > 1 )
    {
      if ( Inx == NULL )
      {
	do
	{
	  /* do Iteration */
	  IterNr++;

	  if (DBL >= 4)
	  {
	    fprintf(debug,"Iteration %3d\n",IterNr);
	  }

	  /* If the list is o.k. "exchanged" remains on 0 */
	  Exchanged = 0;

	  for ( i = 0; i < Entries-1 ; i++ )
	  {
	    if ( *(Val + i) >= *(Val + i + 1) )
	    {
	      /* Eintrag 1 >= Eintrag 2 o.k. */
	      if ( DBL >= 4 )
	      {
		fprintf(debug,"#%3d: %7.2f >= %7.2f ok\n"
		  ,i,*(Val + i),*(Val + i +1) );
	      }
	    }
	    else
	    {
	      /* Eintrag 1 < Eintrag 2 o.k. */
	      TempDouble	   = *(Val + i);
	      *(Val + i)	   = *(Val + i + 1);
	      *(Val + i + 1) = TempDouble;

	      if ( DBL >= 4 )
	      {
		fprintf(debug,"#%3d: %7.2f <  %7.2f <->\n"
		  ,i,*(Val + i),*(Val + i +1)  );
	      }

	      Exchanged = 1;
	    }

	  } /* end for */

	  if ( IterNr> IterNrMax )
	  {
	    if (debug)
	      fprintf(debug,"Aborting after %d iterations\n",IterNr);

	    break;
	  }

	  /* Stop after first pass without exchange */
	} while(Exchanged != 0);

	if(DBL>=3)
	{
	  fprintf(debug,"\nSorted values\n");
	  for(i=0; i<Entries; i++)
	    fprintf(debug,"%3d %f\n",i,*(Val+i) );
	  fflush(debug);
	}

      } /* end if Inx == NULL */
      else
      {
	/* Sort the index to the list */
	do
	{
	  /* do Iteration */
	  IterNr++;

	  if (DBL >= 4)
	    fprintf(debug,"Iteration %3d\n",IterNr);

	  /* If the list is o.k. "exchanged" remains on 0 */
	  Exchanged = 0;

	  for ( i = 0; i < Entries-1 ; i++ )
	  {
	    if ( *(Val + *(Inx+i)) >= *(Val + *(Inx+ i +1) ) )
	    {
	      /* Eintrag 1 > Eintrag 2 o.k. */
	      if ( DBL >= 4 )
	      {
		fprintf(debug,"#%3d: %7.2f >= %7.2f ok\n"
		  ,i,*(Val + *(Inx+i)),*(Val + *(Inx+i+1)) );
	      }
	    }
	    else
	    {
	      if ( DBL >= 4 )
	      {
		fprintf(debug,"#%3d: %7.2f <  %7.2f <->\n"
		  ,i,*(Val + *(Inx+i)),*(Val + *(Inx+i+1)) );
	      }

	      TempInt	  = *(Inx + i);
	      *(Inx + i)	  = *(Inx + i + 1);
	      *(Inx + i + 1)  = TempInt;

	      Exchanged = 1;
	    }

	  } /* end for */

	  if ( IterNr> IterNrMax )
	  {
	    if (debug)
	      fprintf(debug,"Aborting after %d iterations\n",IterNr);

	    break;
	  }

	  /* Stop after first pass without exchange */
	} while(Exchanged != 0);

	if(DBL>=3)
	{
	  fprintf(debug,"\nSorted index\n");
	  for(i=0; i<Entries; i++)
	    fprintf(debug,"Index[%3d] %3d %f\n",i,*(Inx+i),*(Val+*(Inx+i)) );
	  fflush(debug);
	}
      }

  }
  if (debug)
  {
    if(DBL > 0)
    {
      fprintf(debug," Number of Iterations %d\n",IterNr);
      fprintf(debug,"\\END\tFUNCTION %s\n",FktId);
    }
    else
    {
      fprintf(debug,"%d iterations\n",IterNr);
    }
    fflush(debug);
  }

  return 0;
}
/* FUNCTION SortDouble END ****************************************************/


/* FUNCTION ReadPeakFile ******************************************************/
/* 001003 char FileP in header as pointer */
int ReadPeakFile
( const char *PeakFP, int PkAnzMax, double *Adr, double *Frq, double *FrqP, double *Int )
{
  static const char FktId[] = "ReadPeakFile 001003";

  char TempStr[STRING_MAXLENGTH];

  int i;
  int PkAnz = 0;
  int PkNr;

  FILE *PeakF;

  double TmpD1,TmpD2,TmpD3,TmpD4;

  if (debug && DBL>0)
  {
    (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  PeakF=fopen(PeakFP,"r");
  if ( PeakF==NULL )
  {
    if (debug) (void)fprintf(debug,"ERROR opening '%s'\n",PeakFP);
    return(-1);
  }

  /* Read FileHeader */
  for ( i=1; i <= 4; i++ )
  {
    fgets(TempStr,STRING_MAXLENGTH-1,PeakF);
    if (DBL >= 4) (void)fprintf(debug,TempStr);
  }
  if(debug)fflush(debug);

  /* Read file into ARRAY */

  for (PkNr = 0; PkNr < PkAnzMax; PkNr++)
  {
    if( fscanf(PeakF,"%*d %lf %lf %lf %lf"
      ,&TmpD1,&TmpD2,&TmpD3,&TmpD4
      )<4)
    {
      /* End of File reached */
      break;
    }

    if( Adr!=NULL )
    {
      *(Adr+PkNr)=TmpD1;
    }
    if( Frq!=NULL )
    {
      *(Frq+PkNr)=TmpD2;
    }
    if( FrqP!=NULL )
    {
      *(FrqP+PkNr)=TmpD3;
    }
    if( Int!=NULL )
    {
      *(Int+PkNr)=TmpD4;
    }

    if (DBL >= 3)
    {
      (void)fprintf(debug,"%6d%12.1f%13.2f%13.4f%13.2f\n"
	,PkNr+1,TmpD1,TmpD2,TmpD3,TmpD4);
    }

    PkAnz=PkNr+1;
  }

  /* Close PeakF */
  (void)fclose(PeakF);

  if (debug)
  {
    if(DBL > 0)
    {
      (void)fprintf(debug," RESULT: Found %d peaks in file\n",PkAnz);
      (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    }
    else
    {
      (void)fprintf(debug,"<FUNCTION '%s' -> %d frequencies\n",FktId,PkAnz);
    }
    fflush(debug);
  }

  return(PkAnz);
}
/* END FUNCTION ReadPeakFile **************************************************/

/* FUNCTION ReadPeakFile_2 ****************************************************/
/* 001003 char FileP in header as pointer */
/* 090819 eub uses XML file */
int ReadPeakFile_2
( const char *PeakFP, int PkAnzMax, double *Adr, double *Frq, double *FrqP, double *Int )
{
  static const char FktId[] = "ReadPeakFile_2 090819";


  int PkAnz = 0;
  int PkNr;


  if (debug && DBL>0)
  {
    (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  PkAnz = readPeakList(PeakFP);
  if ( PkAnz < 0 )
  {
    if (debug) (void)fprintf(debug,"ERROR opening '%s'\n",PeakFP);
    return(-1);
  }


  /* Read file into ARRAY */

  for (PkNr = 0; PkNr < PkAnz; PkNr++)
  {
    *(Adr+PkNr) = getPeakAddress(PkNr);
    *(Frq+PkNr) = getPeakFreqHz(PkNr);
    *(FrqP+PkNr) = getPeakFreqPPM(PkNr);
    *(Int+PkNr) = getPeakIntensity(PkNr);

    if (DBL > 0)
    {
      (void)fprintf(debug,"%6d%12.1f%13.2f%13.4f%13.2f\n"
	,PkNr+1,*(Adr+PkNr),*(Frq+PkNr),*(FrqP+PkNr),*(Int+PkNr));
    }
  }

  /* Close PeakF */
  freePeakList();

  if (debug)
    (void)fprintf(debug,"<FUNCTION '%s' -> %d frequencies\n",FktId,PkAnz);
  fflush(debug);

  return(PkAnz);
}
/* END FUNCTION ReadPeakFile_2 ************************************************/


/* FUNCTION WritePeakFile *****************************************************/
/* 050818 file write with "wt"						      */
/* 090819 eub detects XLM format by .xml or .XML extension		      */
/* 110302 eub replaced by WritePeakFile					      */
/******************************************************************************/
int WritePeakFile
( const char *curdat, const char *PeakFP, int FrqAnz, double *Adr, double *Frq, double *FrqP, double *Int )
{
  static const char FktId[] = "WritePeakFile 110302";

  if (debug)
  {
    (void)fprintf(debug,"<FUNCTION '%s': use WritePeakFile_2\n",FktId);
    fflush(debug);
  }
  (void)WritePeakFile_2( curdat, PeakFP, FrqAnz, Adr, Frq, FrqP, Int, 0. );

  return(0);
}
/* END FUNCTION WritePeakFile *************************************************/


/* FUNCTION WritePeakFile_2 ***************************************************/
/* 050818 file write with "wt"						      */
/* 090819 eub detects XLM format by .xml or .XML extension		      */
/* 110302 eub derived from WritePeakFile, format corrected, SR corr. added    */
/******************************************************************************/
int WritePeakFile_2
( const char *curdat, const char *PeakFP, int FrqAnz, double *Adr, double *Frq, double *FrqP, double *Int, float SR1Dppm )
{
  static const char FktId[] = "WritePeakFile 110302";

  int FrqNr;
  char TempStr[STRING_MAXLENGTH];
  char DateStr[64];
  FILE *PeakF;

  if (debug)
  {
    (void)fprintf(debug,"/FUNCTION '%s': write %d peaks into\n'%s'\n"
      ,FktId,FrqAnz,PeakFP);
    fflush(debug);
  }


  /* Open peakfile for writing */
  PeakF=fopen(PeakFP,"wt");
  if ( PeakF==NULL )
  {
    if (debug)
    {
      (void)fprintf(debug,"ERROR opening '%s'\n",PeakFP);
    }
    return(-1);
  }

  if( strstr(PeakFP,".xml") || strstr(PeakFP,".XML") )
  {
    /* Write XML format */
    Iso8601XmlDateTime(DateStr, sizeof(DateStr));

    /* Create FileHeader */
    (void)sprintf(TempStr,
      "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<PeakList>\n  <PeakList1D>\n"
      "    <PeakList1DHeader creator=\"%s\" date=\"%s\""
      " expNo=\"%d\" name=\"%s\" owner=\"\" procNo=\"%d\" source=\"%s\">\n"
      "      <PeakPickDetails>F1=0.000ppm, F2=0.000ppm, MI=0.00cm, MAXI=0.00cm, PC=0.000\n"
      "      </PeakPickDetails>\n"
      "    </PeakList1DHeader>\n",
      FktId,DateStr,expno,name,procno,disk);
    (void)fprintf(PeakF,TempStr);
    if (DBL > 0)
      (void)fprintf(debug,TempStr);

    /* Write entries from ARRAY starting with Frq[0]! */
    for (FrqNr = 0; FrqNr < FrqAnz; FrqNr++)
    {
      (void)sprintf(TempStr
	,"    <Peak1D F1=\"%.4f\" intensity=\"%f\" type=\"0\"/>\n"
	,FrqP[FrqNr] - SR1Dppm,Int[FrqNr]);
      (void)fprintf(PeakF,TempStr);

     if (DBL > 0)
     {
       (void)fprintf(debug,TempStr);
     }
    }

    /* Write footer */
    (void)sprintf(TempStr,
      "  </PeakList1D>\n"
      "</PeakList>");
    (void)fprintf(PeakF,TempStr);
    if (DBL > 0)
      (void)fprintf(debug,TempStr);
  }
  else
  {
    /* Write old type ASCII file */
   if (debug)
    {
      (void)fprintf(debug
	,"WARNING Use TEXT format. For XML format use '.xml' or '.XML' as extension\n");
    }

    /* Create FileHeader */
    (void)fprintf(PeakF,"DU=%s, USER=%s, NAME=%s, EXPNO=%i, PROCNO=%i\n"
    ,disk,user,name,expno,procno);
    (void)fprintf(PeakF,"F1=%.3fppm, F2=%.3fppm, MI=%.2fcm, MAXI=%.2fcm, PC=%.3f\n"
      ,0.,0.,0.,0.,0.);
    (void)fprintf(PeakF,"%6s%12s%13s%13s%13s\n"
      ,"#","ADDRESS","FREQUENCY","","INTENSITY");
    (void)fprintf(PeakF,"%6s%12s%13s%13s%13s\n"
      ,"","","[HZ]","[PPM]","");

    /* Write entries from ARRAY starting with Frq[0]! */
    for (FrqNr = 0; FrqNr < FrqAnz; FrqNr++)
    {
      (void)sprintf(TempStr
	,"%6d%12.1f%13.3f%13.4f%13.2f\n"
	,FrqNr,Adr[FrqNr],Frq[FrqNr],FrqP[FrqNr],Int[FrqNr]);
      (void)fprintf(PeakF,TempStr);

      if (DBL)
	(void)fprintf(debug,TempStr);
    }

  }

  /* Close peakfile */
  (void)fflush(PeakF);
  (void)fclose(PeakF);


  if (debug )
  {
    (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION WritePeakFile_2 ***********************************************/


/* FUNCTION ReadMdconF ********************************************************/
/* 001003 char FileP in header as pointer				      */
int ReadMdconF
( char *FileP, int PkAnzMax, double *FrqP, double *Hwb, double *Err )
{
  static const char FktId[] = "ReadMdconF 001003";

  char TempStr[STRING_MAXLENGTH];

  int i;
  int PkAnz = 0;
  int PkNr;

  char TempStr2[STRING_MAXLENGTH];
  FILE *PeakFile;

  double TmpD1;

  if (DBL >= 1)
  {
    (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  PeakFile=fopen(FileP,"r");
  if ( PeakFile==NULL )
  {
    if (debug)
      fprintf(debug,"ERROR opening\n'%s'\n",FileP);
    return(-1);
  }
  else
  {
    if (debug)
      fprintf(debug,"Read up to %d peaks from\n'%s'\n"
      ,PkAnzMax,FileP);
  }

  /* Read FileHeader */
  if (DBL >= 3)
    (void)fprintf(debug,"Read header\n");
  for ( i=1; i <= 6; i++ )
  {
    fgets(TempStr,STRING_MAXLENGTH-1,PeakFile);
    if (DBL >= 3)
    {
      (void)fprintf(debug,TempStr);
      fflush(debug);
    }
  }

  /* Read file into ARRAY */
  PkNr=0;
  strcpy(TempStr,"");
  while (PkNr < PkAnzMax)
  {
    fgets(TempStr,STRING_MAXLENGTH-1,PeakFile);
    if (DBL >= 3)
    {
	fprintf(debug,"%s",TempStr);
    }

    if(
      sscanf(TempStr,"%lf %lf %lf %lf %lf %lf %lf"
      ,&*(FrqP+PkNr),&TmpD1,&TmpD1,&*(Hwb+PkNr),&TmpD1,&TmpD1,&TmpD1 )==7
      )
    {
      /* Peakdata found */
      if (DBL >= 3)
	(void)fprintf(debug,"->Peak %.3f %.3f\n",*(FrqP+PkNr),*(Hwb+PkNr));
    }
    else
    {
      if(
	sscanf(TempStr,"%s %lf %lf %lf %lf %lf"
	,TempStr2,&TmpD1,&TmpD1,&TmpD1,&*(Err+PkNr),&TmpD1)==6
	)
      {
	/* peak deviation data found */
	if (DBL >= 3)
	  (void)fprintf(debug,"->Peak dev %.3f\n'%s' %f %f\n"
	  ,*(Err+PkNr),TempStr2,*(Err+PkNr),TmpD1);
	PkNr++;
      }
      else
      {
	if( strcmp(TempStr,"")==0 )
	{
	  if (DBL >= 3)
	  {
	    fprintf(debug,"->end of file reached\n");
	    fflush(debug);
	  }

	  break;
	}
	else
	{
	  /* unbekannte Zeile weiter */
	  if(DBL >= 3)
	  {
	    fprintf(debug,"->CANNOT identify\n");
	  }
	}
      }


      /* Reset TempStr before next read */
      strcpy(TempStr,"");

      if(debug)fflush(debug);

    }
  }

  /* if Peak is found, PkNr is incremented to Peak+1 */
  PkAnz=PkNr;

  /* Close peakfile */
  (void)fclose(PeakFile);

  if (debug)
  {
    if(DBL > 0)
    {
      (void)fprintf(debug,"Found %d peaks in file\n",PkAnz);
      (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    }
    else
    {
      (void)fprintf(debug,"<FUNCTION '%s': read %d peaks\n",FktId,PkAnz);
    }
    fflush(debug);
  }

  return(PkAnz);
}
/* END FUNCTION ReadMdconF ****************************************************/


/* For compatibility only, use Funktion KeyWords_2 */
int KeyWords
( char *KeyW, int Position, const char *Action, const char *KeyWAkt, const char *KeyWNew )
{
  return( KeyWords_2( KeyW, Position, Action, KeyWAkt, KeyWNew, NULL ) );
}
/* FUNCTION KeyWords_2 ********************************************************/
/* Cuts a string into pieces (separated by blanks) and evaluates the parts    */
/* Action 'd' deletes the KeyWAkt (if found)				      */
/* Action 'a' adds the KeyWAkt at Position (and deletes any occures at other positions) */
/* Action 'r' replaces KeyWAkt by KeyWNew (or adds it a the end, if not found) */
/* In any case the appearance of the KeyWAkt in the original string is reported */
/* 090115 eub blank in FRONT of inserted keyword, Part-definition corr.       */
/* 090809 eub replaced with KeyWords_2, FoundMsg			      */
/******************************************************************************/
int KeyWords_2
( char *KeyW, int Position, const char *Action, const char *KeyWAkt, const char *KeyWNew, const char *FoundMsg )
{
  static const char FktId[] = "KeyWords 090809";
  char Message[PATH_MAX] = "";

  char	Part[17][79];
  int	KeyWNr = 1;
  int	KeyWAnz = 0;
  char	KeyWIntern[PATH_MAX] = "";
  int	KeyWFound = 0;
  char	KeyWNewIntern[PATH_MAX];

  if(DBL>0)
  {
    (void)fprintf(debug,"\n/START\tFUNCTION '%s'\n",FktId);
    switch( Action[0] )
    {
    case 'd':
      fprintf(debug,"(d)elete '%s' from '%s'\n",KeyWAkt,KeyW);
      break;
    case 'f':
      fprintf(debug,"(f)ind '%s' in '%s'\n",KeyWAkt,KeyW);
      break;
    case 'a':
      fprintf(debug,"(a)dd '%s' to '%s'\n",KeyWAkt,KeyW);
      break;
    case 'r':
      fprintf(debug,"(r)eplace '%s' by '%s' in '%s'\n",KeyWAkt,KeyWNew,KeyW);
      break;
    }
    fflush(debug);
  }

  if( KeyWNew!=NULL )
    strcpy(KeyWNewIntern,KeyWNew);
  else
    strcpy(KeyWNewIntern,KeyWAkt);


  /* divide string into keyword */
  KeyWAnz = sscanf(KeyW,"%s %s %s %s %s %s %s %s %s %s %s %s %s %s %s %s "
    ,Part[1],Part[2],Part[3],Part[4],Part[5],Part[6],Part[7],Part[8]
    ,Part[9],Part[10],Part[11],Part[12],Part[13],Part[14],Part[15],Part[16]);
  if(DBL>0)fprintf(debug,"%d parts found\n",KeyWAnz);

  for( KeyWNr=1; KeyWNr<=KeyWAnz; KeyWNr++ )
  {
    /* If position is reached add the new word */
    if(Action[0] == 'a' && KeyWNr == Position )
    {
      if(debug)fprintf(debug
	,"#%d insert Part '%s'\n"
	,KeyWNr,KeyWNewIntern);
      sprintf(KeyWIntern,"%s %s",KeyWIntern,KeyWNewIntern);
    }

    /* Now check what should happen with the current Part */
    if(DBL>0)
    { fprintf(debug,"#%d '%s'",KeyWNr,Part[KeyWNr]); }
    if( strcmp(KeyWAkt,Part[KeyWNr])==0 )
    {
      /* is is the KeyWW we are looking for, so check the action */
      if(DBL>0)fprintf(debug,"== '%s' ",KeyWAkt);
      /* In any case report as found */
      KeyWFound = 1;
      switch( Action[0] )
      {
      case 'd':
	/* do not copy into new string */
	if(DBL>0)fprintf(debug,"-> report&delete!");
	break;
      case 'f':
	/* copy into new string */
	sprintf(KeyWIntern,"%s %s",KeyWIntern,Part[KeyWNr]);
	if(DBL>0)fprintf(debug,"-> report!");
	break;
      case 'a':
	/* do not copy, because it was or will be inserted in defined position */
	if( Position == 0 )
	{
	  sprintf(KeyWIntern,"%s %s",KeyWIntern,Part[KeyWNr]);
	  if(DBL>0)
	    fprintf(debug,"-> keep!");
	}
	else
	{
	  if(DBL>0)
	    fprintf(debug
	    ,"-> report&delete (new position %d)!"
	    ,Position);
	}
	break;
      case 'r':
	/* copy new keyword into new string */
	sprintf(KeyWIntern,"%s %s",KeyWIntern,KeyWNewIntern);
	if(DBL>0)
	  fprintf(debug
	  ,"-> replace by '%s'",KeyWNewIntern);
	break;
      }
    }
    else
    {
      /* It is NOT the KeyWW we are looking for, so just copy */
      sprintf(KeyWIntern,"%s %s",KeyWIntern,Part[KeyWNr]);
      if(DBL>0)
	fprintf(debug,"!= '%s' -> keep",KeyWAkt);
    }
    if(DBL>0){fprintf(debug,"\n"); fflush(debug);}
  }

  /* Add the new keyword now, not yet done */
  if( KeyWFound == 0 && (Action[0] == 'a' || Action[0] == 'r') )
  {
    /* Execute add/replace now if it was not found */
    sprintf(KeyWIntern,"%s %s",KeyWIntern,KeyWNewIntern);
    if(DBL>0)
      fprintf(debug
      ,"#%d add '%s' as new (not yet done)\n"
      ,KeyWNr,KeyWNewIntern);
  }

  /* Only if action was FIND, then string remain unchanged */
  if( Action[0]!='f' )
  {
    strcpy(KeyW,KeyWIntern);
    if(debug)sprintf(Message,"%s, KeyW='%s'"
      ,Message,KeyWIntern);
  }


  if( debug )
  {
    if(KeyWFound)
    {
      sprintf(Message,"'%s' found",KeyWAkt);
      switch( Action[0] )
      {
      case 'd':
	sprintf(Message,"%s&deleted",Message);
	break;
      case 'r':
	sprintf(Message,"%s&replaced by '%s'",Message,KeyWNewIntern);
	break;
      case 'f':
	if( FoundMsg != NULL )
	  sprintf(Message,"%s = %s",Message,FoundMsg);
	break;
      }
    }
    else
    {
      sprintf(Message,"'%s' NOT found",KeyWAkt);
      switch( Action[0] )
      {
      case 'r':
      case 'a':
	sprintf(Message,"%s '%s' added",Message,KeyWNewIntern);
	break;
      }
    }

    (void)fprintf(debug,"<FUNCTION %s->(%d):\t%s\n",FktId,KeyWFound,Message);
    fflush(debug);
  }

  return KeyWFound;
}
/* END FUNCTION KeyWords_2 ****************************************************/


/* FUNCTION RepLine ***********************************************************/
/* 001003 char FileP in header as pointer				      */
/* 001012 \n added to line!						      */
/* 050818 write with option 't' for correct linefeed			      */
/* 080311 eub does not add and does not required '\n' at end of file	      */
/* 080323 eub update with Show_meta if modified title			      */
/******************************************************************************/
int RepLine
( const char *curdat, const char *FileP, const char *KeyW, const char *Info )
{
  static const char FktId[] = "RepLine 080323";
  char Message[PATH_MAX] = "";

  /* System variables */
  char TempStr[STRING_MAXLENGTH];

  char ActLine[STRING_MAXLENGTH] = "";

  /* path+name of files */
  char FileTmpP[PATH_MAX];
  FILE *File,*FileTmp;

  /* Variables for program */
  unsigned KeyWordL;
  int InfoWritten = 0;
  char AddLF[1] = "";

  if(DBL > 0)
  {
    (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fprintf(debug,"Write '%s'='%s'\ninto '%s'\n",KeyW, Info, FileP);
    fflush(debug);
  }
  /* KeyWordlength */
  KeyWordL = strlen(KeyW);

  /* Create name of temporary file */
  (void)sprintf(FileTmpP,"%s.tmp",FileP);

  /* Open actual file */
  File = fopen(FileP,"r");

  /* Info */
  if ( DBL >= 2 )
  {
    fprintf(debug,"Temp. file: '%s'\n",FileTmpP);
  }

  /* Open temporary file as text file for correct linefeed */
  FileTmp = fopen(FileTmpP,"wt");

  if ( FileTmp == NULL )
  {
    /* Temporary file no accessible ABORT */
    if (debug) fprintf(debug,"\nWARNING File '%s' not accessible\n",FileTmpP);
    (void)fflush(debug);

    return(-1);
  }
  else
  {
    /* Check if 'File' must be evaluated */
    if ( File != NULL )
    {
      /* Copy line by line and replace the one with the keyword */
      while ( fgets(ActLine,STRING_MAXLENGTH-1,File) != 0 )
      {
	if ( strlen(ActLine) >= KeyWordL )
	{
	  /* reset TempStr */
	  strcpy(TempStr,"");

	  /* copy the first characters with -hopefully- the keyword */
	  strncat(TempStr,ActLine,KeyWordL );

	  if ( strncmp(TempStr,KeyW,KeyWordL)==0 )
	  {
	    if ( DBL >= 3 )
	      fprintf(debug,"KeyWord found '%s' == '%s'\n",TempStr,KeyW);

	    /* Replace this line with actual information */
	    if( ActLine[strlen(ActLine)-1]!='\n' )
	    {
	      (void)sprintf(ActLine,"%s%s",KeyW,Info);
	    }
	    else
	    {
	      (void)sprintf(ActLine,"%s%s\n",KeyW,Info);
	    }

	    /* Keyword was found */
	    InfoWritten = 1;
	    strcat(Message," replace info ");
	  }
	}

	/* Copy the line (original or modified) to temp. file */
	(void)fprintf(FileTmp,"%s",ActLine);
      }
    }
    else
    {
      /* New file */
      strcat(Message," new file ");
    }

    /* 'title' no existing or without keyword */
    if ( InfoWritten == 0 )
    {
      if (DBL>0)
	fprintf(debug," No KeyWord, add new line\n");
      strcat(Message," add info ");

      if( strlen(ActLine)>0 && ActLine[strlen(ActLine)-1]!='\n' )
      {
	(void)fprintf(FileTmp,"\n");
      }

      /* KeyWord not found, so add one new line withOUT linefeed */
      (void)fprintf(FileTmp,"%s%s%s",AddLF,KeyW,Info);
    }

    /* Close temporary file */
    (void)fflush(FileTmp);
    (void)fclose(FileTmp);

    /* Replace old tile file and remove tmp file */
    (void)dircp(FileTmpP,FileP);
    (void)unlink(FileTmpP);

    /* Initialize the display in TopSpin */
    if( !strcmp(FileP,PROCPATH("title")) )
    {
      if(DBL>0) AUMessage("Update display\n");
      Show_meta(SM_PROC);
    }

    /* Write result to debug */
    if (debug)
    {
      (void)fprintf(debug,"<FUNCTION %s: %s '%s'\n",FktId,Message,Info);
      fflush(debug);
    }
  }

  return 0;
}
/* END FUNCTION RepLine *******************************************************/


/* FUNCTION FindLine *********************************************************/
/* 001003 char FileP in header as pointer */
int FindLine
( const char *curdat, const char *FileP, const char *KeyW, char *Info )
{
  static const char FktId[] = "FindLine 001010";

  /* System variables */
  char TempStr[STRING_MAXLENGTH];

  char ActLine[STRING_MAXLENGTH];

  /* path+name of files */
  FILE *File;

  /* Variables for program */
  unsigned KeyWordL;
  int KeyWFound = 0;

  if (debug)
  {
    (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* KeyWordlength */
  KeyWordL = strlen(KeyW);

  /* Open file */
  File = fopen(FileP,"r");

  /* Info */
  if (DBL >= 2)
  {
    fprintf(debug,"Search: '%s' in\n'%s'\n",KeyW,FileP);
  }

  /* Check if 'File' must be evaluated */
  if ( File != NULL )
  {
    /* reset ActLine */
    strcpy(ActLine,"");

    /* Get line by line */
    while ( fgets(ActLine,STRING_MAXLENGTH-1,File) != 0 )
    {
      if ( strlen(ActLine) >= KeyWordL )
      {
	if ( strncmp(KeyW,ActLine,KeyWordL)==0 )
	{
	  if ( DBL >= 3 )
	    fprintf(debug,"KeyWord found '%s' == '%s'\n",ActLine,KeyW);

	  /* Assign Rest of line to */
	  strcpy(TempStr,ActLine+KeyWordL);

	  /*EUBC Remove linefeed */
	  strcpy(Info,TempStr);

	  /*EUBC Remove linefeed */
	  (void)strtok(Info,"\n");

	  if(debug)
	    fprintf(debug,"ActLine (%d)'%s'\nTempStr (%d)'%s'\nInfo (%d)'%s'\n"
	    ,strlen(ActLine),ActLine,strlen(TempStr),TempStr,strlen(Info),Info);

	  /* Keyword was found */
	  KeyWFound = 1;
	}
      }
    }
  }
  else
  {
    if(debug)
      fprintf(debug,"ERROR file not found\n");
  }

  /* No file or without keyword */
  if ( KeyWFound == 0 )
  {
    if (debug)
      fprintf(debug," No KeyWord found\n");
  }

  /* Write result to debug */
  if (debug)
  {
    (void)fprintf(debug," Result '%s'='%s '\n",KeyW,Info);
    (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return 0;
}
/* END FUNCTION FindLine ******************************************************/


/* FUNCTION SpecificName ******************************************************/
/* Creates a string from datasetname and expno which has a max. of	      */
/* 14 characters, so that it is suitable for f1list names etc.		      */
/* 001003 additional parameter 'length'					      */
/* 010920 eub \n in short output					      */
/* 040310 eub correct report for too long name				      */
/* FUNCTION SpecificName ******************************************************/
int SpecificName ( const char *curdat, char *SName, int GesLen )
{
  static const char FktId[] = "SpecificName 040310";

  /* Length available for the name */
  int NameLen,RestLen,ExpnoLen;

  /* expno as string */
  char ExpnoStr[32];

  if (debug && DBL>0)
  {
    (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    if(DBL >= 2)
      fprintf(debug,"Creating name of %d length from '%s' %d\n"
      ,GesLen,name,expno);
    fflush(debug);
  }

  /* Expno into string */
  sprintf(ExpnoStr,"%d",expno);
  ExpnoLen=strlen(ExpnoStr);

  /* Evaluate name */
  NameLen = strlen(name);

  if(DBL >= 3)
  {
    fprintf(debug,"Length: expno %d=%d digits name '%s'=%d digits\n"
      ,expno,ExpnoLen,name,NameLen);
    fflush(debug);
  }

  /* Max. length of 14 to allow additonal letter */
  if ( (NameLen + ExpnoLen) <= GesLen )
  {
    /* o.k. use as specific name */
    (void)sprintf(SName,"%s%d",name,expno);
  }
  else
  {
    /* Calculate available length for name */
    RestLen = GesLen - ExpnoLen;
    /* reset name */
    strcpy(SName,"");
    /* cut name */
    strncat(SName,name,RestLen);
    /* fill with expno */
    strcat(SName,ExpnoStr);

    if (debug)
    {
      fprintf(debug
	,"\nWARNING specific name '%s%d' too long\nuse '%s' instead\n"
	,name,expno,SName);
    }
  }

  if (debug)
  {
    if(DBL > 0)
    {
      fprintf(debug,"Specific name for dataset '%s'\n",SName);
      (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    }
    else
    {
      (void)fprintf(debug,"<FUNCTION '%s' -> '%s'\n",FktId,SName);
    }
    fflush(debug);
  }

  return 0;
}
/* END FUNCTION SpecificName **************************************************/


/* FUNCTION ReadFrqList *******************************************************/
/* Reads an array of double values from a f1-list compatible format	      */
/* If Frq  != NULL the values are stored in Hz into Frq[0..FrqAnz-1]	      */
/* If FrqP != NULL the values are stored in ppm into FrqP[0..FrqAnz-1]	      */
/* Values can be converted by an SR value				      */
/* First entry is Frq[0]! use &Frq[1] for lcsetsup compatibility	      */
/* Complete path must be given, typically getstan(0,0)lists/f1/f1listname     */
/* 030130 Hz instead of ppm reported, corrected				      */
/* 041124 access to FrqP only if != NULL				      */
/* 080617 report FrqP with debug, not only with DBL>0			      */
/******************************************************************************/
int ReadFrqList
( const char *FrqLstP, int FrqAnzMax, float SR, double *Frq, double *FrqP )
{
  static const char FktId[] = "ReadFrqList 080617";

  int FrqAnz = 0;
  int FrqNr;
  double TempDouble;
  double BF1;

  char TempStr[PATH_MAX];
  FILE *FrqList;

  if (debug)
  {
    (void)fprintf(debug,"/START\tFunction '%s': Max %d frq\n'%s'\n"
      ,FktId, FrqAnzMax, FrqLstP);
    fflush(debug);
  }

  FrqList = fopen(FrqLstP,"r");
  if ( FrqList == NULL )
  {
    if (debug) (void)fprintf(debug,"ERROR opening '%s'\n",FrqLstP);
    FrqAnz= 0;
  }
  else
  {
    /* Read FileHeader */
    fscanf( FrqList,"%*s %lf",&BF1);
    if ( DBL >= 2 )
      (void)fprintf(debug,"BF1 from header %fMHz\nApply SR %.2fHz\n",BF1,SR);

    /* Read file into ARRAY */
    for ( FrqNr = 0; FrqNr < FrqAnzMax; FrqNr++)
    {
      if ( fscanf(FrqList,"%lf",&TempDouble )<1)
      { /* End of File reached */
	break;
      }

      if ( Frq != NULL )
      {
	Frq[FrqNr] = TempDouble - (double)SR;
	sprintf(TempStr," %.1fHz",Frq[FrqNr]);
      }

      if ( FrqP != NULL )
      {
	FrqP[FrqNr] = (TempDouble - (double)SR)/BF1;
	sprintf(TempStr," %.3fppm",FrqP[FrqNr]);
      }

      if (DBL>0)
      { (void)fprintf(debug,"%d %s\n", FrqNr, TempStr); fflush(debug); }

      /* Entry 'FrqNr' sucesfully read */
      FrqAnz = FrqNr + 1;
    }
    (void)fclose(FrqList);
  }

  if (DBL>0)
  {
    for( FrqNr = 0; FrqNr < FrqAnz; FrqNr++)
    {
      if(FrqP != NULL )
	(void)fprintf(debug," %.3fppm",FrqP[FrqNr]);
      if(Frq != NULL )
	(void)fprintf(debug," %.3fHz",Frq[FrqNr]);
      (void)fprintf(debug,"//");
    }
    (void)fprintf(debug,"\n");
  }

  if( debug )
  {
    fprintf(debug,"\\END\tFUNCTION %s: read %d values\n"
      ,FktId,FrqAnz);
    fflush(debug);
  }

  return(FrqAnz);
}
/* END FUNCTION ReadFrqList ***************************************************/


/* FUNCTION WriteFrqList ******************************************************/
/* Writes an array of double values into a f1-list compatible format	      */
/* First entry is Frq[0]! use &Frq[1] for lcsetsup compatibility	      */
/* Complete path must be given, typically getstan(0,0)lists/f1/f1listname     */
/* 050818 file write with "wt"						      */
/* BEGIN FUNCTION WriteFrqList ************************************************/
int WriteFrqList( const char *FrqListFP, int FrqAnz, double BF1Set, double *Frq  )
{
  static const char FktId[] = "WriteFrqList 050818";

  int FrqNr;
  FILE *FrqListF;

  if (debug)
  {
    if(DBL > 0)
    {
      fprintf(debug,"/START\tFUNCTION '%s'\n%d frequencies ",FktId,FrqAnz);
      for (FrqNr=0; FrqNr < FrqAnz; FrqNr++)
      {
	(void)fprintf( debug, " %.2f", Frq[FrqNr] );
      }
      fprintf(debug,"Hz\ninto '%s'\n",FrqListFP);
    }
    else
    {
      fprintf(debug,"<FUNCTION '%s' write  %d frequencies\n",FktId,FrqAnz);
    }
    fflush(debug);
  }


  /* Open file for write */
  FrqListF=fopen(FrqListFP,"wt");
  if ( FrqListF==NULL )
  {
    if (debug)
      (void)fprintf(debug,"ERROR opening '%s'\n",FrqListFP);
    return(-1);
  }


  /* Write FileHeader */
  (void)fprintf(FrqListF,"O%9.3f\n",BF1Set);

  if (DBL >= 2)
  {
    (void)fprintf(debug,"O%9.3f\n",BF1Set);
  }


  /* write the frequency entries */
  for (FrqNr=0; FrqNr < FrqAnz; FrqNr++)
  {
    (void)fprintf( FrqListF , "%.3f\n", Frq[FrqNr] );
  }


  /* Close the frequency list */
  (void)fflush(FrqListF);
  (void)fclose(FrqListF);

  if (debug && DBL>0)
  {
    (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION WriteFrqList **************************************************/

/* FUNCTION WriteFrqList2 *****************************************************/
/* Writes an array of double values into a f1-list compatible format	      */
/* First entry is Frq[0]! use &Frq[1] for lcsetsup compatibility	      */
/* Complete path must be given, typically getstan(0,0)lists/f1/f1listname     */
/* With SR as parameter							      */
/* 050818 file write with "wt"						      */
/* BEGIN FUNCTION WriteFrqList ************************************************/
int WriteFrqList2( const char *FrqListFP, int FrqAnz, double BF1Set, double *Frq, double SR )
{
  static const char FktId[] = "WriteFrqList 050818";

  int FrqNr;
  FILE *FrqListF;

  if (debug)
  {
    if(DBL > 0)
    {
      fprintf(debug,"/START\tFUNCTION '%s'\n%d frequencies ",FktId,FrqAnz);
      for (FrqNr=0; FrqNr < FrqAnz; FrqNr++)
      {
	(void)fprintf(debug, " %.2f", Frq[FrqNr]);
      }
      fprintf(debug,"Hz\ninto '%s'\n",FrqListFP);
    }
    else
    {
      fprintf(debug,"<FUNCTION '%s' write  %d frequencies\n",FktId,FrqAnz);
    }
    fflush(debug);
  }


  /* Open file for write */
  FrqListF=fopen(FrqListFP,"wt");
  if ( FrqListF==NULL )
  {
    if (debug)
      (void)fprintf(debug,"ERROR opening '%s'\n",FrqListFP);
    return(-1);
  }


  /* Write FileHeader */
  (void)fprintf(FrqListF,"O%9.3f\n",BF1Set);

  if (DBL >= 2)
  {
    (void)fprintf(debug,"O%9.3f\n",BF1Set);
  }


  /* write the frequency entries */
  for (FrqNr=0; FrqNr < FrqAnz; FrqNr++)
  {
    (void)fprintf( FrqListF , "%.3f\n", Frq[FrqNr] + SR );
  }


  /* Close the frequency list */
  (void)fflush(FrqListF);
  (void)fclose(FrqListF);

  if (debug && DBL>0)
  {
    (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION WriteFrqList2 *************************************************/

/* BEGIN FUNCTION WriteRegFile ************************************************/
/* Assumes that Border[] contains limits for region in the		      */
/* format Border[0]=Start[1], Border[1]=End[1]				      */
/* 050818 file write with "wt"						      */
/******************************************************************************/
int WriteRegFile( const char *RegFP, int RegionAnz, double *Border )
{
  static const char FktId[] = "WriteRegFile 050818";

  char TempStr[PATH_MAX];
  FILE *RegF;
  int RegNr;
  /* First line of region file */
  char FileHeader[PATH_MAX] = "P    #regions in PPM\n# low field   high field\n";

  if (debug)
  {
    if(DBL > 0)
    {
      fprintf(debug,"/START\tFUNCTION '%s'\n%d regions ",FktId,RegionAnz);
      for ( RegNr = 0; RegNr < RegionAnz; RegNr++ )
      {
	(void)fprintf(debug," [%.3f %.3fppm]"
	  ,*(Border + 2*RegNr),*(Border + 2*RegNr +1));
      }
      fprintf(debug,"\ninto '%s'\n",RegFP);
    }
    else
    {
      fprintf(debug,"<FUNCTION '%s': write %d regions\n",FktId,RegionAnz);
    }
    fflush(debug);
  }

  /* Open reg-file for writing */
  RegF=fopen(RegFP,"wt");
  if ( RegF==NULL )
  {
    if (debug)
    {
      (void)fprintf(debug,"ERROR opening '%s'\n",RegFP);
      fflush(debug);
    }
    return(-1);
  }

  /* Create FileHeader */
  (void)fprintf(RegF,FileHeader);
  if (DBL >= 2 )
  {
    (void)fprintf(debug,FileHeader);
  }

  /* Write regions */
  for ( RegNr = 0; RegNr < RegionAnz; RegNr++ )
  {
    (void)sprintf(TempStr,"  %.14f  %.14f  # for region %d\n"
      ,*(Border + 2*RegNr),*(Border + 2*RegNr +1),RegNr+1);

    (void)fprintf(RegF,TempStr);
    if (DBL >= 2 )
    {
      fprintf(debug,TempStr);
    }
  }

  /* Close regfile */
  (void)fflush(RegF);
  (void)fclose(RegF);


  if (debug && DBL>0)
  {
    (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION WriteRegFile **************************************************/

/* BEGIN FUNCTION WriteIntrng *************************************************/
/* Assumes that Border[] contains limits for region in the		      */
/* format Border[0]=Start[1], Border[1]=End[1]				      */
/* if Bias == NULL, the the simple format is written			      */
/* 050818 file write with "wt"						      */
/******************************************************************************/
int WriteIntrng
( const char *RegFP, int RegionAnz, double *Border, double *Bias, double *Slope )
{
  static const char FktId[] = "WriteIntrng 050818";

  char TempStr[PATH_MAX];
  FILE *RegF;
  int RegNr;

  /* First line of region file */
  char FileHeader[PATH_MAX] = "P 0\n";

  if (debug)
  {
    if(DBL > 0)
    {
      fprintf(debug,"/START\tFUNCTION '%s'\n%d regions ",FktId,RegionAnz);
      for ( RegNr = 0; RegNr < RegionAnz; RegNr++ )
      {
	(void)fprintf(debug," [%.3f %.3fppm]"
	  ,*(Border + 2*RegNr),*(Border + 2*RegNr +1));
      }
      fprintf(debug,"\ninto '%s'\n",RegFP);
    }
    else
    {
      fprintf(debug,"<FUNCTION '%s': write %d regions\n",FktId,RegionAnz);
    }
    fflush(debug);
  }

  /* Open reg-file for writing */
  RegF=fopen(RegFP,"wt");
  if ( RegF==NULL )
  {
    if (debug)
    {
      (void)fprintf(debug,"ERROR opening '%s'\n",RegFP);
      fflush(debug);
    }
    return(-1);
  }

  /* Create FileHeader */
  (void)fprintf(RegF,FileHeader);
  if (DBL >= 2 )
  {
    (void)fprintf(debug,FileHeader);
  }

  /* Write regions */
  for ( RegNr = 0; RegNr < RegionAnz; RegNr++ )
  {
    (void)sprintf(TempStr,"  %.6f  %.6f\n"
      ,*(Border + 2*RegNr),*(Border + 2*RegNr +1));

    (void)fprintf(RegF,TempStr);
    if (DBL >= 2 )
    {
      fprintf(debug,TempStr);
    }
  }

  /* Close intrng-file */
  (void)fflush(RegF);
  (void)fclose(RegF);


  if (debug && DBL>0)
  {
    (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION WriteRegFile **************************************************/


/* BEGIN FUNCTION ReadRegFile *************************************************/
/* Assumes that Border[] contains limits for region in the		      */
/* format Border[0]=Start[1], Border[1]=End[1]				      */
/******************************************************************************/
int ReadRegFile( const char *RegFP, int RegAnzMax, double *Reg )
{
  static const char FktId[] = "ReadRegFile 001009";

  char TempStr[PATH_MAX];
  FILE *RegF;
  int RegNr,RegAnz=0;

  if (debug)
  {
    if(DBL>=1)
    {
      fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
      fprintf(debug,"Read max. %d Region(s) from\n'%s'\n"
	,RegAnzMax,RegFP);
    }
    fflush(debug);
  }

  /* Open reg-file for writing */
  RegF=fopen(RegFP,"r");
  if ( RegF==NULL )
  {
    if (debug)
    {
      (void)fprintf(debug,"ERROR opening '%s'\n",RegFP);
      fflush(debug);
    }
    return(-1);
  }

  /* Read FileHeader */
  (void)fgets(TempStr,(int)(PATH_MAX-1),RegF);
  if (DBL >= 4 )
  {
    (void)fprintf(debug,"Header\n'%s'",TempStr);
  }

  /* Write regions */
  for ( RegNr = 0; RegNr < RegAnzMax; RegNr++ )
  {
    strcpy(TempStr,"");
    (void)fgets(TempStr,(int)(PATH_MAX-1),RegF);
    if ( sscanf(TempStr,"%lf%lf",&*(Reg + 2*RegNr),&*(Reg + 2*RegNr +1)) == 2 )
    {
      /* succesfully read */
      if (DBL >= 3 )
	fprintf(debug,"Line %d ='%s' -> %7.3f %7.3f\n"
	,RegNr,TempStr,*(Reg + 2*RegNr),*(Reg + 2*RegNr +1));
      RegAnz=RegNr+1;
    }
    else
    {
      if (DBL >= 3 )
	fprintf(debug,"End of file or error in '%s'\n",TempStr);
      break;
    }

  }

  /* Close regfile */
  (void)fclose(RegF);


  if (debug)
  {
    if(DBL >= 0)
    {
      (void)fprintf(debug," RESULT Found %d regions in file\n",RegAnz);
      for( RegNr = 0; RegNr < RegAnz; RegNr++ )
      {
	fprintf(debug,"%3d %7.3f %7.3f\n"
	  ,RegNr,*(Reg + 2*RegNr),*(Reg + 2*RegNr +1) );
      }
      (void)fprintf(debug,"\\END\tFUNCTION '%s'->(%d)\n"
	,FktId,RegNr);
    }
    else
    {
      (void)fprintf(debug,"<FUNCTION %s: read %d regions\n",FktId,RegNr);
    }
    fflush(debug);
  }

  return(RegAnz);
}
/* END FUNCTION WriteRegFile **************************************************/


/* BEGIN FUNCTION GenReg ******************************************************/
/* Assumes that Border[0] and Border[1] contain the outer		      */
/* limits into which Border[2..AnzEntr] should be sorted		      */
/* function returs n pairs of start/end values, n<AnzEntr/2		      */
/* 001009 eub output							      */
/* 010822 eub output							      */
/******************************************************************************/
int GenReg( int AnzEntr, double *Border )
{
  static const char FktId[] = "GenReg 010822";

  int Entry,RegNr,i,BorderNr;
  int Index[MAXPEAKNR],Typ[MAXPEAKNR];
  double BorderT[MAXPEAKNR];
  int Layers,LayersLast;


  if (debug)
  {
    if (DBL>=1)
    {
      fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
      fprintf(debug,"Check %d regions within %.3f - %.3f\n"
	,(int)((AnzEntr-2)/2),*Border,*(Border+1));
    }
    fflush(debug);
  }

  /* Copy borders to temporary array */
  /* Set type before sorting */

  /* Typ of 0 and 1 are invers to other entries */
  *(BorderT) = *(Border);
  *(Typ) = -1;
  *(BorderT+1) = *(Border+1);
  *(Typ+1)= 1;

  /* Copy Border[] into temporary array BorderT[] */
  for (i=1; i<(AnzEntr/2); i++ )
  {
    *(BorderT+2*i) = *(Border+2*i);
    *(Typ+2*i) = 1;
    *(BorderT+2*i+1) = *(Border+2*i+1);
    *(Typ+2*i+1)= -1;
  }

  /* Sort temporary array BorderT */
  (void)SortDouble( AnzEntr, Index, BorderT );

  /* Region Starts when 0 layers are reached */
  /* Region Ends when 0 layers are left */
  Layers = 1;
  BorderNr = 0;
  for( Entry =0; Entry < AnzEntr; Entry++ )
  {
    LayersLast = Layers;
    Layers = Layers + *(Typ+Index[Entry]);

    if (DBL>=3)
      fprintf(debug,"(%d) %7.3f  Layers=%d  Typ=%d"
      ,Entry,*(BorderT+Index[Entry]),Layers,*(Typ+Index[Entry]) );

    if (    ((Layers == 0) && (LayersLast>0))
      || ((Layers == 1) && (LayersLast==0))
      )
    {
      Border[BorderNr] = *(BorderT+Index[Entry]);
      if (DBL>=3)
	fprintf(debug,"======%d\n",BorderNr);
      BorderNr++;
    }
    else
    {
      if (DBL>=3)
	fprintf(debug,"[\n");
    }
  }

  if (debug)
  {
    fprintf(debug
      ,"<FUNCTION %s: Created %d regions\n",FktId,(int)(BorderNr/2));
    if(DBL>=1)
    {
      for( RegNr = 0; RegNr<(int)(BorderNr/2); RegNr++ )
      {
	fprintf(debug,"%3d %7.3f %7.3f\n"
	  ,RegNr,*(Border+2*RegNr),*(Border+2*RegNr+1));
      }
      (void)fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    }
    fflush(debug);
  }

  return( (int)(BorderNr/2) );
}
/* END FUNCTION GenReg ********************************************************/

/* BEGIN FUNCTION GenReg2 *****************************************************/
/* Overlapping entries in a Reg are removed				      */
/* 090212 eub Size of ARRAY corrected					      */
/******************************************************************************/
int GenReg2( int RegAnz, double *Reg )
{
  static const char FktId[] = "GenReg2 090212";

  int BorderAnz;
  int Inx[MAXPEAKNR*2],Typ[MAXPEAKNR*2];
  double RegT[MAXPEAKNR];
  int Layers,LayersLast;

  int	RegNr;
  int	EntNr;

  if (debug)
  {
    if (DBL>=1)
    {
      fprintf(debug,"/START\tFUNCTION '%s': Check %d regions\n",FktId,RegAnz);
      for( RegNr=0; RegNr<RegAnz; RegNr++ )
	fprintf(debug," [%.3f %.3f]",*(Reg + 2*RegNr),*(Reg + 2*RegNr +1));
      fprintf(debug,"\n");
    }
    else
    {
      fprintf(debug,"<FUNCTION %s: Check %d regions ",FktId,RegAnz);
    }
    fflush(debug);
  }

  /* Set start/end of the Region borders */
  for (RegNr=0; RegNr<RegAnz; RegNr++ )
  {
    Typ[RegNr*2   ] =  1;
    Typ[RegNr*2 +1] = -1;
  }

  /* Sort the borders */
  DBL--;
  (void)SortDouble( (int)(RegAnz*2), Inx, Reg );
  DBL++;

  /* Region Ends when layer==0 is reached */
  /* Region Ends when layer==0 is left */
  Layers = 0;
  BorderAnz = 0;

  for( EntNr =0; EntNr < (int)(RegAnz*2); EntNr++ )
  {
    LayersLast = Layers;
    Layers = Layers + *(Typ+Inx[EntNr]);

    if (DBL>=3)
      fprintf(debug,"(%d) %7.3f  Layers %d-(%2d)->%d"
      ,EntNr,*(Reg+Inx[EntNr]),LayersLast,*(Typ+Inx[EntNr]),Layers );

    if ( (Layers == 0) && (LayersLast>0) )
    {
      RegT[BorderAnz] = *(Reg + Inx[EntNr]);
      if (DBL>=3)
	fprintf(debug,"/ %2d\n",(int)(BorderAnz/2));
      BorderAnz++;
    }
    else
    {
      if ( (Layers > 0) && (LayersLast == 0) )
      {
	RegT[BorderAnz] = *(Reg + Inx[EntNr]);
	if (DBL>=3)
	  fprintf(debug,"\\ %2d\n",(int)(BorderAnz/2));
	BorderAnz++;
      }
      else
      {
	if (DBL>=3)
	  fprintf(debug," |\n");
      }
    }
  }

  RegAnz = (int)(BorderAnz/2);

  if(DBL >=1)
    fprintf(debug,"Found %d borders = %d Regions\n",BorderAnz,RegAnz);

  /* Transfer Result from RegT to Reg */
  for( RegNr=0; RegNr < RegAnz; RegNr++ )
  {
    *(Reg + 2*RegNr    ) = *(RegT + 2*RegNr);
    *(Reg + 2*RegNr + 1) = *(RegT + 2*RegNr + 1);
  }

  if (debug)
  {
    if(DBL >0)
    {
      if(DBL>=1)
      {
	for( RegNr = 0; RegNr<RegAnz; RegNr++ )
	{
	  fprintf(debug,"%3d %7.3f %7.3f\n"
	    ,RegNr,*(Reg+2*RegNr),*(Reg+2*RegNr+1));
	}
      }
      (void)fprintf(debug,"Generated %d regions\n\\END\tFUNCTION '%s'\n"
	,RegAnz,FktId);
    }
    else
    {
      fprintf(debug," and found %d valid\n",RegAnz);
    }
    fflush(debug);
  }

  return( RegAnz );
}
/* END FUNCTION GenReg2 *******************************************************/


/* BEGIN FUNCTION RegInters ***************************************************/
/* A new region is created from INclude and EXclude regions		      */
/* InReg defines INclude regions in format Begin/End InReg[n]/InReg[n+1]      */
/* OutReg defines EXclude regions in format Begin/End OutReg[n]/OutReg[n+1]   */
/* The InReg and OutReg regions may also overlap with themselfs		      */
/******************************************************************************/
int RegInters( int InRegAnz, double *InReg, int OutRegAnz, double *OutReg, double *Reg )
{
  static const char FktId[] = "RegInters 010602";

  int Entry,RegNr,BorderNr,RegAnz;
  int Inx[MAXPEAKNR],Typ[MAXPEAKNR];
  double RegT[MAXPEAKNR];
  int Layers,LayersLast;

  if (debug)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    if (DBL>=1)
    {
      fprintf(debug,"%d INclude Regions",InRegAnz);
      for(RegNr=0; RegNr<InRegAnz; RegNr++)
	fprintf(debug," [%.3f - %.3f]",*(InReg+2*RegNr),*(InReg+2*RegNr+1) );
      fprintf(debug,"\n%d EXclude Regions",OutRegAnz);
      for(RegNr=0; RegNr<OutRegAnz; RegNr++)
	fprintf(debug," [%.3f - %.3f]",*(OutReg+2*RegNr),*(OutReg+2*RegNr+1) );
      fprintf(debug,"\n");
    }
    fflush(debug);
  }


  /* Put INclude regions into temporary region */
  for(RegNr=0; RegNr<InRegAnz; RegNr++)
  {
    *(RegT + RegNr*2) = *(InReg + RegNr*2);
    *(Typ + RegNr*2) = -1;
    *(RegT + RegNr*2 + 1) = *(InReg + RegNr*2 + 1);
    *(Typ + RegNr*2 + 1)= 1;
  }

  /* Add EXclude regions into temporary region */
  for(RegNr=0; RegNr<OutRegAnz; RegNr++)
  {
    *(RegT + 2*(RegNr + InRegAnz)) = *(OutReg+RegNr*2);
    *(Typ + 2*(RegNr + InRegAnz)) = 1;
    *(RegT+ 2*(RegNr + InRegAnz) +1) = *(OutReg+RegNr*2+1);
    *(Typ + 2*(RegNr + InRegAnz) +1)= -1;
  }

  /* Total number of regions */
  RegAnz = (int)( InRegAnz + OutRegAnz );

  /* Sort all regions */
  if(debug)fprintf(debug," ");
  (void)SortDouble( (int)(2*RegAnz), Inx, RegT );

  /* Region Starts when 0 layers are reached */
  /* Region Ends when 0 layers are left */
  /* Always assume that outside from EVERYTHING we are outside */
  Layers = 1;
  /* and we have no boarders */
  BorderNr = 0;

  for( Entry =0; Entry < (int)(2*RegAnz); Entry++ )
  {
    LayersLast = Layers;

    Layers = Layers + *(Typ+Inx[Entry]);

    if (DBL>=2)
      fprintf(debug,"(%d) %7.3f  Typ %2d Layers %d->%d  "
      ,Entry,*(RegT+Inx[Entry]),*(Typ+Inx[Entry]),LayersLast,Layers );

    if (    ((Layers == 0) && (LayersLast>0))
      || ((Layers == 1) && (LayersLast==0))
      )
    {
      Reg[BorderNr] = *(RegT+Inx[Entry]);
      if (DBL>=2)
      {
	if(Layers == 0)
	  fprintf(debug,"\\Begin %d\n",(int)(BorderNr/2));
	else
	  fprintf(debug,"/End   %d\n",(int)(BorderNr/2));
      }
      BorderNr++;
    }
    else
    {
      if (DBL>=2)
	fprintf(debug,"|\n");
    }
  }

  RegAnz = (int)(BorderNr/2);


  if (debug)
  {
    if(DBL>=1)
    {
      for( RegNr = 0; RegNr<RegAnz; RegNr++ )
	fprintf(debug," [%.3f %.3f]",*(Reg+2*RegNr),*(Reg+2*RegNr+1));
      fprintf(debug,"\n");
    }
    (void)fprintf(debug,"\\END\tFUNCTION '%s' created %d regions\n",FktId,RegAnz);
    fflush(debug);
  }

  return( RegAnz );
}
/* END FUNCTION RegInters *****************************************************/


/* BEGIN FUNCTION mqfil *******************************************************/
/* Applies multiple QFIL to an FID					      */
/* the frequencies are given by an ARRAY of double values in Hz where Frq[0]  */
/* is the reference frequency. Frq has therefore FrqAnz+1 entries	      */
/* eub 030202 debuggging & description changed apply quad/single at O1	      */
/* BEGIN FUNCTION mqfil *******************************************************/
int mqfil( const char *curdat, int FrqAnz, double *Frq )
{
  static const char FktId[] = "mqfil 030202";


  /* Original Setting of Dataset */
  int BCMODSet,PHMODSet,FTMODSet;
  float BCFWSet;
  double COROFFSSet;
  int WDWSet;

  /* Variables for AU program */
  double Coroffs[MAXSOLVNR];
  int FrqNr;
  int BCMODQfil = 6;
  int BCMODBasic = 2;
  double BCFWQfil;


  if (debug)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    if (DBL >= 2)
      fprintf(debug,"QFIL for %d positions\n",FrqAnz);
    fflush(debug);
  }


  if ( FrqAnz < 1 )
  {
    if (debug)
    {
      fprintf(debug,"\nWARNING no Frequencies defined, no qfil applied\n");
      fflush(debug);
    }
    return(-1);
  }

  /* Get original parameters from experiment */
  FETCHPAR("WDW",&WDWSet);
  FETCHPAR("BC_mod",&BCMODSet);
  switch( BCMODSet )
  {
  case 1:
  case 3:
  case 5:
    BCMODBasic = 1;
    break;
  case 2:
  case 4:
  case 6:
    BCMODBasic = 2;
    break;
  default:
    BCMODBasic = 2;
  }
  FETCHPAR("PH_mod",&PHMODSet);
  FETCHPAR("FT_mod",&FTMODSet);
  FETCHPAR("COROFFS",&COROFFSSet);
  FETCHPAR("BCFW",&BCFWSet);

  /* Check if current bcfw is correct */
  BCFWQfil = BCFWSet;
  if ( BCFWQfil == 0. )
  {
    BCFWQfil = 0.4;
    if (debug)
    {
      fprintf(debug,"\nWARNING 'bcfw'=%.2f used default %.2f\n",BCFWSet,BCFWQfil);
      fflush(debug);
    }
  }
  else
  {
    if ( BCFWQfil > 0.5 )
    {
      if (debug)
      {
	fprintf(debug,"\nWARNING 'bcfw'=%.2f is realtively large!\n",BCFWQfil);
	fflush(debug);
      }
    }
  }

  /* Set parameters for processing */
  STOREPAR("WDW",0);
  STOREPAR("BC_mod",BCMODQfil);
  STOREPAR("BCFW",BCFWQfil);
  STOREPAR("PH_mod",0);
  STOREPAR("FT_mod",0);


  /* Calculate COROFFS in Hz */
  if ( DBL > 1 )
  {
    fprintf(debug,"Calculated Coroffs with O1 %.2fHz: ",*Frq);
    fflush(debug);
  }

  for ( FrqNr=0; FrqNr < FrqAnz; FrqNr++ )
  {
    Coroffs[FrqNr] = *(Frq + FrqNr + 1) - *Frq;
    if (DBL >= 2)
    {
      fprintf(debug," %.2f -> %.2fHz"
	,*(Frq + FrqNr + 1),Coroffs[FrqNr]);
    }
  }
  if (DBL >= 2)
  {
    fprintf(debug
      ,"\nQFIL with %.2fppm @ %d positions @ %.2fHz"
      ,BCFWQfil,FrqAnz,Coroffs[0]);
  }

  /* Apply quad correction at O1 */
  STOREPAR("BC_mod",BCMODBasic);
  CPR_exec("bc",WAIT_TERM);

  /* Apply QFILs */
  STOREPAR("BC_mod",BCMODQfil);
  /* for ( FrqNr=1; FrqNr < FrqAnz; FrqNr++ ) */
  for ( FrqNr=0; FrqNr < FrqAnz; FrqNr++ )
  {
    STOREPAR("COROFFS",Coroffs[FrqNr]);

    CPR_exec("trfp",WAIT_TERM);

    if (DBL >= 2)
      (void)fprintf(debug," %.2fHz",Coroffs[FrqNr]);
  }

  if (DBL >= 2)
    (void)fprintf(debug," (relative to O1)\n");

  /* Restore original parameters for processing */
  STOREPAR("WDW",WDWSet);
  STOREPAR("BC_mod",BCMODSet);
  STOREPAR("BCFW",BCFWSet);
  STOREPAR("PH_mod",PHMODSet);
  STOREPAR("FT_mod",FTMODSet);
  STOREPAR("COROFFS",COROFFSSet);

  if (debug)
  {
    fprintf(debug,"\\END\tFUNCTION '%s'->(%d)\n\n",FktId,FrqAnz);
    fflush(debug);
  }

  return(FrqAnz);
}
/* END FUNCTION mqfil *********************************************************/


/* FUNCTION CreateScaleShape **************************************************/
/* 001103 eub use 'access' instead of 'fopen'				      */
/* 040309 eub blanks in shapename possible				      */
/* 080131 eub phase for shape to 'e'nd					      */
/******************************************************************************/
int CreateScaleShape( double *pFrq, float *pScale, int AnzFrequ, float PulseLength, const char* ShapeStart, const char* ShapeWork, float *pShapeInteg )
{
  static const char FktId[] = "CreateScaleShape 040309";
  char	Message[PATH_MAX] = "";

  /* path+name of used shapes */
  char ShapePNStart[PATH_MAX],ShapePNWork[PATH_MAX];

  char	TempStr[PATH_MAX],InfoStr[PATH_MAX];
  char	StCmdStr[PATH_MAX];
  int	TempInt;
  int	FrequNr;

  if (debug)
  {
    if (DBL >= 1)
      fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* Check if starting shape ist present */
  if ( strcmp(ShapeStart,ShapeWork)==0 )
  {
    if (debug)
      (void)fprintf(debug
      ,"ABORT same name for  Reference '%s' and new shape '%s'\n"
      ,ShapeStart,ShapeWork);
    return(-1);
  }

  /* Create complete names of shapes */
  if (getParfileDirForRead(ShapeStart, SHAPE_DIRS, ShapePNStart) < 0)
  {
    if (debug)
    {
      (void)fprintf(debug,"ABORT, Shape %s: %s\n",ShapeStart,ShapePNStart);
      fflush(debug);
    }
    return(-1);
  }

  if (getParfileDirForWrite(ShapeWork, SHAPE_DIRS, ShapePNWork) < 0)
  {
    if (debug)
    {
      (void)fprintf(debug,"ABORT, Shape %s: %s\n",ShapeWork,ShapePNWork);
      fflush(debug);
    }
    return(-1);
  }

  if ( (TempInt = dircp(ShapePNStart,ShapePNWork)) < 0 )
  {
    Proc_err(0,dircp_err(TempInt));
    ABORT
  }

  if ( pScale == NULL  )
  {
    if (DBL >= 2)
      (void)fprintf(debug
      ,"'%s' -( %d frequencies, (NO scaling) )-> '%s'\n"
      ,ShapeStart,AnzFrequ,ShapeWork);
  }
  else
  {
    if (DBL >= 2)
      (void)fprintf(debug
      ,"'%s' -( %d frequencies, (scaling) )-> '%s'\n"
      ,ShapeStart,AnzFrequ,ShapeWork);
  }

  if ( AnzFrequ > 0 )
  {
    sprintf(Message,"%d frequ. ",AnzFrequ);

    if ( pScale == NULL  )
    {
      /* Manipulate withOUT scaling */

      /* Prepare 'st' command for manipulation withOUT scaling */
      (void)sprintf(StCmdStr
	,"st manipulate \"%s\" offs b %.0f %d "
	,ShapeWork,PulseLength,AnzFrequ);
      (void)sprintf(InfoStr,"Modulation with %d Frequencies\n",AnzFrequ);

      /* Add frequencies to commandline */
      for ( FrequNr=1; FrequNr<=AnzFrequ; FrequNr++ )
      {
	(void)sprintf(TempStr," %.1f"
	  ,*(pFrq+FrequNr)-*pFrq );
	(void)strcat(StCmdStr,TempStr);

	(void)sprintf(TempStr," %.1fHz"
	  ,*(pFrq+FrequNr)-*pFrq);
	(void)strcat(InfoStr,TempStr);

	sprintf(Message,"%s %.1fHz",Message,*(pFrq+FrequNr)-*pFrq);
      }

      (void)strcat(Message," no scaling");
      (void)strcat(InfoStr,"\n");
    }
    else
    {
      /* Manipulate WITH scaling */

      /* Prepare command string WITH scaling */
      (void)sprintf(StCmdStr
	,"st manipulate \"%s\" offs e s %.0f %d "
	,ShapeWork,PulseLength,AnzFrequ);
      (void)sprintf(InfoStr,"Modulation with %d scaled Frequencies\n",AnzFrequ);

      /* Add frequencies and scaling factors to commandline */
      /* start counting with '1' pFrq=Ref, pFrq+1 = first solvent */
      for ( FrequNr=1; FrequNr<=AnzFrequ; FrequNr++ )
      {
	(void)sprintf(TempStr," %.1f %.1f"
	  ,*(pFrq+FrequNr)-*pFrq,*(pScale+FrequNr) );
	(void)strcat(StCmdStr,TempStr);

	(void)sprintf(TempStr," %.1fHz/%.1f%%"
	  ,(*(pFrq+FrequNr)-*pFrq),*(pScale+FrequNr));
	(void)strcat(InfoStr,TempStr);

	sprintf(Message,"%s  %.1fHz x%.2f"
	  ,Message,*(pFrq+FrequNr)-*pFrq,*(pScale+FrequNr)/100.);
      }

      (void)strcat(InfoStr,"\n");
    }

    /* Document and execute 'st' for manipulation of shape */
    if (DBL >= 3)
      (void)fprintf(debug,"st-command = '%s'\n",StCmdStr);

    CPR_exec (StCmdStr, WAIT_TERM);
    /* Document how shape was created */
    {
      FILE *ShapeCmdF;

      sprintf(TempStr,"%s.stc",ShapeWork);
      ShapeCmdF=fopen(ACQUPATH(TempStr),"wt");
      if( ShapeCmdF )
      {
	fprintf(ShapeCmdF,StCmdStr);
	fflush(ShapeCmdF);
	fclose(ShapeCmdF);
      }
    }
  }
  else
  {
    if (debug)
      sprintf(InfoStr
      ,"Only %d frequencies, leaving '%s' unchanged\n"
      ,AnzFrequ,ShapeWork);
    sprintf(Message,"%d frequ - unchanged",AnzFrequ);
  }

  /* Calculate power change */
  *pShapeInteg = (float)(-20.*( log10( (double)AnzFrequ ) ));
  if (debug)
    sprintf(Message,"%s %.1f-dBW",Message,*pShapeInteg);

  if (debug)
  {
    if( DBL>=1)
    {
      fprintf(debug,"RESULT: %s",InfoStr);
      fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    }
    else
    {
      fprintf(debug,"<FUNCTION %s: %s\n",FktId,Message);
    }
    fflush(debug);
  }
  return(0);
}
/* END FUNCTION CreateScaleShape **********************************************/


/* FUNCTION WetPlSet **********************************************************/
/* Calculates the WET powerlevels and stores values in the shape parameters   */
/* Settings for on-flow with SP11..14 is not done			      */
/* 000901 wrong parametername if powerlevel outside limits		      */
/* 001103 eub output changed						      */
/* 090807 eub Use -dBW							      */
/* 090819 eub WPLKorr allow +/- 10dB					      */
/* 110124 eub Check upper level, no absolute limit			      */
/* FUNCTION WetPlSet **********************************************************/
int WetPlSet( const char *curdat, const char* RefShape, double RefPL, double RefOffs, double WPLKorr )
{
  static const char FktId[] = "WetPlSet 110124";

  char TempStr[PATH_MAX];
  char InfoStr[PATH_MAX];
  int ShNr;

  /* The four different WET powerlevels */
  double WPL[4];
  /* is decremented for each error in powercalculation */
  int PLError = 0;
  /* Limits for powerlevel */
  double ShPLimitH = 1000.;
  /* Name of the shapes TP... SP.. */
  char ShNNWet[4][8];
  char ShPNWet[4][8];

  if (debug)
  {
    fprintf(debug,"<FUNCTION %s: set '%s' as WET shape\n",FktId,RefShape);
    fflush(debug);
  }

  /* Define instrument specific parameters */
  if ( is_amx() || isamxr() )
  {
    for ( ShNr = 0; ShNr <= 3; ShNr++ )
    {
      sprintf(ShNNWet[ShNr],"TPNAME%d",ShNr+3);
      sprintf(ShPNWet[ShNr],"TP %d",ShNr+3);
    }
  }
  else
  {
    for ( ShNr = 0; ShNr <= 3; ShNr++ )
    {
      sprintf(ShNNWet[ShNr],"SPNAM%d",ShNr+7);
      sprintf(ShPNWet[ShNr],"SPdB %d",ShNr+7);
    }
  }
  if ( WPLKorr < -10. || WPLKorr > 10. )
  {
    /* No correction if outside limit */
    WPLKorr = 0.;
  }

  /* Check if Reference is defined  */
  (void)sprintf(InfoStr,"'%s'",RefShape);

  if ( RefPL == 0. )
  {
    /* REFERENCE == 0 use current powerlevels */
    (void)sprintf(InfoStr,"%s --.--dBW, fix. ",InfoStr);

    /* Get current powerlevels for documentation only */
    for ( ShNr = 0; ShNr <= 3; ShNr++ )
    {
      /* Powerlevel as calculated */
      FETCHPAR(ShPNWet[ShNr],&WPL[ShNr]);
      (void)sprintf(TempStr," %.1f",WPL[ShNr]);
      strcat(InfoStr,TempStr);
    }
  }
  else
  {
    /* REFERENCE <> 0 calculate powerlevels */
    (void)sprintf(TempStr," %.1f-dBW -> ",RefPL);
    strcat(InfoStr,TempStr);

    /* Calculate new powerlevels from reference */
    WPL[0]=RefPL + 0.87;
    WPL[1]=RefPL - 1.04;
    WPL[2]=RefPL + 2.27;
    WPL[3]=RefPL - 5.05 + WPLKorr ;
    /* Store powerlevels if in valid range */
    for ( ShNr = 0; ShNr <= 3; ShNr++ )
    {
      /* Check if powerlevel is o.k. */
      if ( WPL[ShNr] > ShPLimitH )
      {
	/* Powerlevel outside limits */
	WPL[ShNr]=ShPLimitH;
	PLError--;
      }

      /* Store name and checked powerlevel */
      (void)sprintf(TempStr," %.1f",WPL[ShNr]);
      strcat(InfoStr,TempStr);
      STOREPAR(ShPNWet[ShNr],WPL[ShNr]);
      STOREPAR(ShNNWet[ShNr],RefShape);
    }

    (void)sprintf(TempStr,"(corr. %.2f)",WPLKorr);
    strcat(InfoStr,TempStr);
  }

  /* Complete messages */
  (void)strcat(InfoStr,"-dBW\n");
  if ( PLError != 0 )
  {
    (void)strcat(InfoStr,"ERROR in powercalculation\n");
  }

  /* Show result in infoline and debug file */
  Show_status(InfoStr);
  if (debug && DBL>0)
  {
    (void)fprintf(debug," RESULT %s",InfoStr);
    fprintf(debug,"\\END\tFUNCTION %s->(%d)\n",FktId,PLError);
    fflush(debug);
  }
  return(PLError);
}
/* END FUNCTION WetPlSet ******************************************************/


/* FUNCTION CalcPresScale *****************************************************/
int CalcPresScale ( double *pInn, float *pScale, int AnzFrq )
{
  static const char FktId[] = "CalcPresScale 100203";
  char Message[PATH_MAX];

  /* Program variables */
  int FrqNr;

  /* Frequency with maximum Innsity */
  int FrqNrMaxInt = 0 ;

  Message[0] = 0;

  if (debug)
  {
    if (DBL >= 2)
      fprintf(debug,"/START\tFUNCTION %s\n",FktId);
    fflush(debug);
  }

  if(AnzFrq > 0)
  {
    /* Find maximum intensity, list not necessaryly sorted */
    double Normalize;
    double InnMax = 0.;
    char* cp = Message;

    for ( FrqNr = 0; FrqNr < AnzFrq; FrqNr++ )
    {
      if ( InnMax <= pInn[FrqNr] )
      {
	InnMax = pInn[FrqNr];
	FrqNrMaxInt = FrqNr;
      }
    }

    /* Calculate Normalising factor in % from maximum Intensity */
    Normalize = 100. / sqrt(sqrt( sqrt( InnMax ) ));

    /* Create infostring */
    if ( DBL >= 2)
    {
      (void)fprintf(debug
	,"Maximum Intensity #%d: %.1fcm %.1f%%\nScaling:"
	,FrqNrMaxInt,InnMax,100.);
    }

    /* Calculate Scaling factors from Intensity */
    for ( FrqNr = 0; FrqNr < AnzFrq; FrqNr++ )
    {
      double InnAkt  = pInn[FrqNr];
      double ScalAkt = sqrt(sqrt(sqrt(InnAkt))) * Normalize;

      pScale[FrqNr] = (float)ScalAkt;

      cp += sprintf(cp, "%.2f ", ScalAkt / 100.);
      if ( DBL >= 2 )
      {
	(void)fprintf(debug," %d[%.1fcm %.1f%%] ",FrqNr,InnAkt,ScalAkt);
      }
    }
  }

  if (debug)
  {
    fprintf(debug,"<FUNCTION %s: %d frequ. %s\n"
      ,FktId,AnzFrq,Message);
    fflush(debug);
  }

  return 0;
}
/* END FUNCTION CalcPresScale *************************************************/


/* FUNCTION SetSFO ************************************************************/
/* assigns AnzSolv from the Array pFrq to SFO2 ... SFO<2+AnzSolv-1>.	      */
/* If <2+AnzSolv-1> is smaller then MaxChannel then FrqDef is set to the      */
/* remaining channels.							      */
/* SFO1 must be set outside. If SFO1 is suppression frequ. use pFrq[2]	      */
/* otherwise pFrq[1]							      */
/* fkt nicht mit solvents=0!!!						      */
/* 001012 Range in MHz!!!						      */
/* FUNCTION SetSFO ************************************************************/
int SetSFO( const char *curdat, int AnzSolv, double *pFrq, double *FrqDef, int MaxChannel )
{
  static const char FktId[] = "SetSFO";

  char InfoUnused[STRING_MAXLENGTH];
  int	 AktSolv,Channel,LastChannel;
  double BF1Set,SFOCenter,SFOAkt,SFODefault;
  double Range;
  char SFOName[8];
  char Used[STRING_MAXLENGTH]="";
  char Default[STRING_MAXLENGTH]="";
  char Unchanged[STRING_MAXLENGTH]="";


  if (debug)
  {
    if( DBL >= 1 )
    {
      fprintf(debug,"/START\tFUNCTION %s\n",FktId);
      fprintf(debug,"Set %d solvents to %d channels\n"
	,AnzSolv,MaxChannel-1);
      /* MaxChannel-1 = we always start from SFO2 */
    }
    fflush(debug);
  }


  /* Calculate center of Spectrum */
  FETCHPAR("BF1",&BF1Set);
  SFOCenter=(BF1Set + *pFrq * 1e-6 );

  /* */
  FETCHPARS("SW",&Range);
  Range = Range * BF1Set * 2.e-6;

  SFODefault = (double)(BF1Set + *FrqDef * 1.e-6);

  if( DBL>=2)
  {
    fprintf(debug,"Range %.7fMHz Default Frq %.7fMHz %.2fHz\n"
      ,Range,SFODefault,*FrqDef);
  }

  /* start with SFO2, SFO1 is set outside */
  LastChannel = 1;

  /* Prepare Output */
  strcpy(Used," ");
  strcpy(Default," ");
  strcpy(Unchanged," ");

  /* for EACH solvent */
  for ( AktSolv = 0; AktSolv < AnzSolv; AktSolv++ )
  {
    for ( Channel = LastChannel+1; Channel<=MaxChannel; Channel++ )
    {
      /* Get actual SFO for current channel  */
      (void)sprintf(SFOName,"SFO%d",Channel);
      FETCHPAR(SFOName,&SFOAkt);

      /* Check if SFO is proton frequency */
      if ( fabs( SFOCenter - SFOAkt) <= Range  )
      {
	/* Store frequency */
	STOREPAR(SFOName,(double)(BF1Set + ( *(pFrq+AktSolv) * 1e-6) ) );

	/* (void)sprintf(TempStr," %s=%10.7fMHz "
	,SFOName,(double)(BF1Set + ( *(pFrq+AktSolv) * 1e-6) ));
	strcat(InfoUsed,TempStr); */
	sprintf(Used,"%s(%d)",Used,Channel);

	/* The actual channel is the last SET channel */
	LastChannel = Channel;

	/* Leave the Channel Loop */
	break;
      }
      else
      {
      /* (void)sprintf(TempStr," %s=%10.7fMHz",SFOName,SFOAkt);
	strcat(InfoUnused,TempStr); */
	sprintf(Unchanged,"%s(%d)",Unchanged,Channel);
      }

      if ( Channel > MaxChannel )
	break;
    }
  }

  /* Set remaining channels to default value */
  strcat(InfoUnused,"\nUnused Channels : ");

  for ( Channel = LastChannel+1; Channel <= MaxChannel; Channel++ )
  {
    (void)sprintf(SFOName,"SFO%d",Channel);
    FETCHPAR(SFOName,&SFOAkt);
    if ( fabs( SFOAkt - SFOCenter ) <= Range )
    {
      STOREPAR(SFOName,SFODefault );
      /* (void)sprintf(TempStr," %s",SFOName);
      strcat(InfoUnused,TempStr);  */
      sprintf(Default,"%s(%d)",Default,Channel);
    }
    else
    {
      sprintf(Unchanged,"%s(%d)",Unchanged,Channel);
    }
  }

  if (debug)
  {
    fprintf(debug,"<FUNCTION %s: %s->frq(s)  %s->SFO1  %s=unchanged\n"
      ,FktId,Used,Default,Unchanged);
  }

  return(0);

}
/******************************************************************************/


/* FUNCTION lcabsff ***********************************************************/
/* Executes multiple "absf" in the defined regions			      */
/* For each region a iteration to the borders is performed		      */
/* The original values of ABSF1,ABSF2 are restored			      */
/* 001009 eub reg=double						      */
/******************************************************************************/
int lcabsff( const char *curdat, int AnzReg, double *Reg, double LimitH, double LimitL )
{
  static const char FktId[] = "lcabsff 001009";

  int	RetVal = 0;
  float ABSF1Set = 10.;
  float ABSF2Set =  0.;
  double Left, Right;
  int	RegNr = 0;
  double Range,RangeFull;
  int	ParModeSet = 0;
  char	BaslCmd[16] = "absf";
  int	IntrngCp = 0;

  if (debug)
  {
    if(DBL>=1)
    {
      fprintf(debug,"/START\tFUNCTION '%s': absf in %d regions\n",FktId,AnzReg);
      for( RegNr=0; RegNr<AnzReg; RegNr++ )
	fprintf(debug," [%.3f %.3f]",*(Reg+2*RegNr),*(Reg+2*RegNr+1));
      fprintf(debug,"\n");
    }
    else
    {
      fprintf(debug,"<FUNCTION '%s': absf in %d regions\n",FktId,AnzReg);
    }
    fflush(debug);
  }

  /* Save original ABSF's */
  FETCHPAR("ABSF1",&ABSF1Set);
  FETCHPAR("ABSF2",&ABSF2Set);

  /* Save orig. intrng */
  if ( !access(PROCPATH("intrng"),F_OK) )
  {
    dircp( PROCPATH("intrng"),PROCPATH("intrng.tmp") );
    IntrngCp = 1;
    if (DBL>=3)
      fprintf(debug,"Save 'intrng'\n'%s'\n",PROCPATH("intrng.tmp"));
  }

  /* Check if 1D or 2D */
  FETCHPAR("PPARMOD",&ParModeSet);

  if (ParModeSet == 0)
    sprintf(BaslCmd,"absf");
  else
    sprintf(BaslCmd,"abs2");

  if (DBL>=2)
  {
    fprintf(debug,"BaslCmd '%s'  Iteration limits %.2f, %.2f\n"
      ,BaslCmd,LimitH,LimitL);
  }

  for ( RegNr=0; RegNr<AnzReg; RegNr++ )
  {
    Left = *(Reg + 2*RegNr);
    Right = *(Reg + 2*RegNr +1);
    RangeFull = Left - Right;

    if ( RangeFull > 0.01 )
    {
      /* Set ABSF's to actual region */
      STOREPAR("ABSF1", Left );
      STOREPAR("ABSF2", Right );

      /* over whole actual region */
      if ( CPR_exec(BaslCmd,WAIT_TERM) )
      {
	RetVal = -1;
	if (debug) fprintf(debug,"Full [%.3f - %.3f](ERROR)\n",Left,Right);
      }
      else
      {
	if (DBL>=2) fprintf(debug,"Full [%.3f - %.3f](OK)\n",Left,Right);
      }

      /* fixed left border */
      STOREPAR("ABSF1",Left);
      if (DBL>=3)
	fprintf(debug,"Left [%.3f ",Left);

      /* Startpoint = middle */
      Range = RangeFull * .5;

      while ( Range >= LimitL )
      {
	/* Store right border */
	STOREPAR("ABSF2",Left - Range );

	/* Apply baseline in 1D or 2D */
	CPR_exec(BaslCmd,WAIT_TERM);
	if (DBL>=3)
	  (void)fprintf(debug,"- %.3f)",Left - Range);

	/* For large range go immediately to LimitH */
	if ( Range > LimitH )
	{
	  Range = LimitH;
	}
	else
	{
	  Range = Range * 0.5;
	}
      }

      if (DBL>=3)
      {
	(void)fprintf(debug,"\n     ");
	fflush(debug);
      }

      Range = RangeFull * 0.5;

      /* fixed right Border */
      STOREPAR("ABSF2",Right);

      while ( Range >= LimitL )
      {
	STOREPAR("ABSF1",Right + Range);


	/* Carry out baseline correction */
	CPR_exec(BaslCmd,WAIT_TERM);

	if (DBL>=3)
	  (void)fprintf(debug,"(%.3f - ",Right + Range);

	/* For large range go immediately to LimitH */
	if ( Range > LimitH )
	{
	  Range = LimitH;
	}
	else
	{
	  Range = Range * 0.5;
	}
      }

      if (DBL>=3)
      {
	fprintf(debug,"%.3f] Right\n",Right);
	fflush(debug);
      }
    }
    else
    {
      if (DBL>=3) fprintf(debug,"(TOO SMALL)\n");
    }
  }


  /* Restore original ABSF's */
  STOREPAR("ABSF1",ABSF1Set);
  STOREPAR("ABSF2",ABSF2Set);

  /* Restore orig. intrng */
  if ( IntrngCp == 1 )
  {
    dircp( PROCPATH("intrng.tmp"),PROCPATH("intrng") );
    unlink( PROCPATH("intrng.tmp") );
    if (DBL>=3)
      fprintf(debug,"Restore '%s'\n",PROCPATH("intrng"));
  }
  else
  {
    unlink( PROCPATH("intrng") );
  }

  if (debug)
  {
    if(DBL >= 1)
    {
      fprintf(debug," RESULT: '%s' for %d region(s) within %.3f - %.3fppm\n"
	,BaslCmd,AnzReg,*Reg,*(Reg + 2*(AnzReg-1) +1));
      fprintf(debug,"\\END\tFUNCTION '%s' -> (%d)\n",FktId,RetVal);
    }
    fflush(debug);
  }

  return(RetVal);
}
/* END FUNCTION lcabsff *******************************************************/


/* FUNCTION lcabsff BEGIN *****************************************************/
/* carries out a baseline correction in the given limits		      */
/* the original values for ABSF1 and ABSF2 are restored			      */
/* FUNCTION lcabsff BEGIN *****************************************************/
int lcabsff_001008( char *curdat, float ABSF1Proc, float ABSF2Proc )
{
  static const char FktId[] = "lcabsff 001008";

  float ABSF1Set,ABSF2Set;
  int PARMODESet = 0;

  if (debug)
  {
    fprintf(debug,"<FUNCTION '%s': absf from %.3f - %.3fppm\n",FktId,ABSF1Proc,ABSF2Proc);
    fflush(debug);
  }

  FETCHPARS("PARMODE",&PARMODESet);

  /* Save original ABSF's */
  FETCHPAR("ABSF1",&ABSF1Set);
  FETCHPAR("ABSF2",&ABSF2Set);

  /* Set ABSF's to requested region */
  STOREPAR("ABSF1",ABSF1Proc);
  STOREPAR("ABSF2",ABSF2Proc);

  /* Execute baselinecorrection in ABSF's */
  if ( PARMODESet == 0 )
  {
    CPR_exec("absf",WAIT_TERM);
  }
  else
  {
    CPR_exec("abs2",WAIT_TERM);
  }

  /* Restore original ABSF's */
  STOREPAR("ABSF1",ABSF1Set);
  STOREPAR("ABSF2",ABSF2Set);

  if (debug && DBL>0)
  {
    fprintf(debug,"\\END\tFUNCTION '%s'->(%d)\n\n",FktId,0);
    fflush(debug);
  }

  return(0);

}
/* END FUNCTION lcapkff *******************************************************/


/* FUNCTION lcapkff BEGIN *****************************************************/
/* carries out a phase correction in the given limits */
/* the original values for ABSF1 and ABSF2 are restored */
/* FUNCTION lcapkff BEGIN *********************************************************/
int lcapkff( const char *curdat, float ABSF1Proc, float ABSF2Proc )
{
  static const char FktId[] = "lcapkff 001008";

  float ABSF1Set,ABSF2Set;

  if (debug)
  {
    fprintf(debug,"<FUNCTION '%s': apkf in %.3f - %.3fppm\n"
      ,FktId,ABSF1Proc,ABSF2Proc);
    fflush(debug);
  }

  /* Save original ABSF's */
  FETCHPAR("ABSF1",&ABSF1Set);
  FETCHPAR("ABSF2",&ABSF2Set);

  /* Set ABSF's to requested region */
  STOREPAR("ABSF1",ABSF1Proc);
  STOREPAR("ABSF2",ABSF2Proc);

  /* Execute baselinecorrection in ABSF's */
  CPR_exec("apkf",WAIT_TERM);

  /* Restore original ABSF's */
  STOREPAR("ABSF1",ABSF1Set);
  STOREPAR("ABSF2",ABSF2Set);

  return(0);

}
/* END FUNCTION lcapkff *******************************************************/


/* BEGIN Function CalcExpTime *************************************************/
/* 001013 def of ExpTimeStr wrong					      */
/******************************************************************************/
int CalcExpTime35( const char *curdat )
{
  static const char FktId[] = "CalcExpTime 1.0 001014";

  char ExptFileN[PATH_MAX];
  FILE* fp;
  char* retp = 0;
  char inputline[PATH_MAX];
  int tim;
  char TempStr[PATH_MAX];
  char ExpTimeStr[PATH_MAX];

  if (DBL >= 1)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* write result to actual dataset */
  (void)sprintf(ExptFileN,ACQUPATH("expt") );
  (void)sprintf(TempStr,"expt %s",ExptFileN);
  if( DBL >= 3 )
    fprintf(debug,"Temp. File:\n'%s'\n",ExptFileN);

  CPR_exec(TempStr, WAIT_TERM);

  fp = fopen(ExptFileN, "rt");
  if (fp)
  {
    retp = fgets(inputline, PATH_MAX, fp);
    fclose(fp);
  }

  /* save inputline */
  strcpy(ExpTimeStr,inputline);
  if(DBL >= 2)
    fprintf(debug,"Input: '%s'\n",inputline);

  if (fp && retp)
  {
    int days = 0, hours = 0, minutes = 0, seconds = 0;

    int nargs = sscanf(inputline, "experiment time = %d%*s%d%*s%d%*s%d",
			   &days, &hours, &minutes, &seconds);
    switch (nargs)
    {
    case 1:
      seconds = days;
      days = 0;
      break;

    case 2:
      seconds = hours;
      hours = 0;
      minutes = days;
      days = 0;
      break;

    case 3:
      seconds = minutes;
      minutes = hours;
      hours = days;
      days = 0;
      break;
    case 4:
      break;
    default:
      nargs = sscanf(inputline, "experimenttime %d", &seconds);
      if (nargs != 1)
      {
	if (debug)
	  fprintf(debug,"illegal format of expt command output\n");
	return 0;
      }
    }
    tim = (((days * 24) + hours) * 60 + minutes) * 60 + seconds;
  }
  else
  {
    if (debug) (void)fprintf(debug,"calculation of experiment time failed\n");
    return( -1 );
  }

  if (debug)
  {
    fprintf(debug,"<FUNCTION %s: %dsec\n",FktId,tim);
    fflush(debug);
  }

  return tim;
}
/* END Function CalcExpTime ***************************************************/


/* Limits 1.0 *****************************************************************/
/* Returns the limits of the current spectrum als Border[0,1]		      */
/* Also consideres effects of strip-transformation and SR		      */
/* 001009 eub double							      */
/******************************************************************************/
int Limits( const char *curdat, double *Left, double *Right )
{
  static const char FktId[] = "Limits 001009";

  float  OFFSET;
  double SW_p;
  double BF1Set;

  if (debug && DBL>0)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* Sweepwidth in Hz, incl. stsi etc. */
  FETCHPARS("SW_p",&SW_p);
  /* yields correct value ( incl. SR !!) */
  FETCHPARS("OFFSET",&OFFSET);
  /* necessary for recalculation of SW_p in ppm */
  FETCHPARS("BF1",&BF1Set);

  if ( DBL>=2 )
  {
    fprintf(debug," PARAMETERS: BF1 %.7fMHz, OFFSET %.3fppm, SW_p %.1fHz\n"
      ,BF1Set,OFFSET,SW_p);
  }

  /* Calculate borders of actual spectrum */
  *Left  = (double)(OFFSET);
  *Right = (double)( *Left - SW_p/BF1Set );

  if (debug)
  {
    fprintf(debug,"<FUNCTION '%s': limits are %.3f - %.3fppm\n"
      ,FktId,*Left,*Right);
    fflush(debug);
  }

  return 0;
}
/******************************************************************************/


/* InsideF ********************************************************************/
/* Border[0,1] contains the outer limit of a region  [ ]		      */
/* Border[2..Anz] contains further regionlimits				      */
/* If a limit is beyond right of left border, it is set to right/left border  */
/* If (after this) Border[2*n]<Border[2*n+1] the values are exchanged	      */
/* The number of regions is not changed, some regions migth have a size of 0  */
/* 001009 eub double							      */
/******************************************************************************/
int InsideF( int RegAnz, double Left, double Right, double *Reg )
{
  static const char FktId[] = "InsideF 001009";

  double TempDouble;
  int RegNr;
  int Entry;

  if (debug)
  {
    if(DBL>=1)
      fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* Check each ENTRY if outside limits */
  for ( Entry = 0; Entry < 2*RegAnz; Entry++ )
  {
    if ( *(Reg+Entry) > Left )
    {
      if ( DBL>=3 )
	fprintf(debug,"%.3f -> %.3f\n",*(Reg+Entry),Left);
      *(Reg+Entry) = Left;
    }
    else
    {
      if ( *(Reg+Entry) < Right )
      {
	if ( DBL>=3 )
	  fprintf(debug,"%.3f -> %.3f\n",*(Reg+Entry),Right);
	*(Reg+Entry) = Right;
      }
      else
      {
	if ( DBL>=3 )
	  fprintf(debug,"%.3f o.k.\n",*(Reg+Entry));
      }
    }
  }

  /* Check REGION if pairs have to be exchanged */
  for ( RegNr = 0; RegNr<RegAnz; RegNr++ )
  {
    if ( *(Reg+2*RegNr) < *(Reg+2*RegNr+1))
    {
      TempDouble = *(Reg+2*RegNr);
      *(Reg+2*RegNr) = *(Reg+2*RegNr+1);
      *(Reg+2*RegNr+1) = TempDouble;
      if ( DBL>=3 )
	fprintf(debug,"%.3f <-> %.3f\n",*(Reg+2*RegNr),*(Reg+2*RegNr+1));
    }
    if (DBL>=4)
    {
      fprintf(debug,"(%d)[%.3f-%.3f]\n"
	,RegNr,*(Reg+2*RegNr), *(Reg+2*RegNr+1));
    }
  }

  if (debug)
  {
    if(DBL>=1)
    {
      fprintf(debug," RESULT: Produced %d region(s) in %.3f - %.3f\n"
	,RegAnz,Left,Right);
      for( RegNr = 0; RegNr<RegAnz; RegNr++ )
      {
	fprintf(debug,"%3d %7.3f %7.3f\n",RegNr,*(Reg+2*RegNr),*(Reg+2*RegNr+1));
      }
      fprintf(debug,"\\END\tFUNCTION '%s'->(%d)\n",FktId,RegAnz);
    }
    else
    {
      fprintf(debug,"<FUNCTION %s: Created %d regions\n",FktId,RegAnz);
    }
    fflush(debug);
  }

  return(RegAnz);
}
/******************************************************************************/


/* FUNCTION GetFrqLstP ********************************************************/
/* Trys to find a valid name for the frequency list defined for this	      */
/* dataset.								      */
/* The order is F1LIST/FQ1LIST 'f1list' in current dataset for AMX/ARX	      */
/* The order is FQ1LIST/F1LIST 'f1list' in current dataset for AVANCE	      */
/* The 'f1list' in the current dataset is generated by the LCNMR Automation   */
/* programs during solvent search					      */
/* 010822 eub use KEYWORD instead of f1list for curd			      */
/* 010918 eub search in ACQUPATH instead of PROCPATH			      */
/******************************************************************************/
int GetFrqLstP( const char *curdat, char *FrqLstP )
{
  static const char FktId[] = "GetFrqLstP 010918";

  int FrqLstFound = -1;
  char FrqLstType[32] = "";
  char FrqLstPTmp[PATH_MAX];
  char FrqLstNN1[PATH_MAX];
  char FrqLstNN2[PATH_MAX];
  char FrqLstN[PATH_MAX];


  if (debug && DBL>0)
  {
    (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }


  /* Name of frequency list in eda */
  if ( is_amx() || isamxr() )
  {
    strcpy(FrqLstNN1,"F1LIST");
    strcpy(FrqLstNN2,"FQ1LIST");
    if (DBL >= 3)
      (void)fprintf(debug,"AMX/ARX spectrometer use 'F1LIST'\n");
  }
  else
  {
    strcpy(FrqLstNN1,"FQ1LIST");
    strcpy(FrqLstNN2,"F1LIST");
    if (DBL >= 3)
      (void)fprintf(debug,"AVANCE spectrometer use 'FQ1LIST'\n");
  }


  /* Search list defined via "eda|F1LIST,FQ1LIST" */
  FETCHPAR(FrqLstNN1,FrqLstN);

  sprintf(FrqLstPTmp, "Parameter %s not set", FrqLstNN1);
  if (FrqLstN[0] && getParfileDirForRead(FrqLstN, F1_DIRS, FrqLstPTmp) >= 0)
  {
    strcpy(FrqLstP,FrqLstPTmp);
    FrqLstFound = 0;
    sprintf(FrqLstType,"is %s",FrqLstNN1);
  }
  else
  {
    if (DBL >= 3)
      (void)fprintf(debug,"%s: %s\n",FrqLstN,FrqLstPTmp);

    /* Search list defined via "eda|F1LIST,FQ1LIST" */
    FETCHPAR(FrqLstNN2,FrqLstN);

    sprintf(FrqLstPTmp, "Parameter %s not set", FrqLstNN2);
    if (FrqLstN[0] && getParfileDirForRead(FrqLstN, F1_DIRS, FrqLstPTmp) >= 0)
    {
      strcpy(FrqLstP,FrqLstPTmp);
      FrqLstFound = 0;
      sprintf(FrqLstType,"is %s",FrqLstNN2);
    }
    else
    {
      if (DBL >= 3)
	(void)fprintf(debug,"%s: %s\n",FrqLstN,FrqLstPTmp);

      sprintf(FrqLstPTmp,ACQUPATH(NAMEF1LISTCURD) );
      if ( access(FrqLstPTmp,F_OK) == 0 )
      {
	strcpy(FrqLstP,FrqLstPTmp);
	FrqLstFound = 0;
	sprintf(FrqLstType,"is '%s' in 'curd'",NAMEF1LISTCURD);
      }
      else
      {
	if (DBL >= 3)
	  (void)fprintf(debug,"File not found\n'%s'\n",FrqLstPTmp);
	sprintf(FrqLstType,"was not found");
      }
    }
  }

  if (debug)
  {
    if( DBL >= 1 )
    {
      fprintf(debug," '%s' -> '%s'\n",FrqLstType,FrqLstP);
      fprintf(debug,"\\END\tFUNCTION %s\n",FktId);
    }
    else
      fprintf(debug,"<FUNCTION %s: %s\n",FktId,FrqLstType);

    fflush(debug);
  }

  return(FrqLstFound);
}
/* END FUNCTION GetFrqLstP ****************************************************/


/* FUNCTION DetRG *************************************************************/
/* Determines the RG for the current experiment				      */
/* RGStrt this value is stored to RG before RGA starts			      */
/*	  far away from expected value -> simulates DS			      */
/* RGMin  minimum value of RG, if RGA yield value below, RGMin is used	      */
/* RGMax  maximum value -"-						      */
/* RGCtrl Control for RG						      */
/*	  <= -1 use as fixed RG, all other parameters have no meaning	      */
/*	  =   0 no RGA is done						      */
/*	  >   0 RG from RGA is multiplied with the value		      */
/* 000903 eub DEMO_MODE suported					      */
/* 001010 if RGCtrl = 0 RGDef is stored to RG instead of leaving it unchanged */
/* 001103 eub output changed						      */
/* 020705 eub DE->50u during RGA					      */
/* 030303 eub DE from D31						      */
/* 041124 eub uses AcquSave2						      */
/* 041218 eub automatic DE for CRP, DEMin=DESet				      */
/* 060704 eub DE for cryoprobes via DEFINE in DE_CRYO reduced to 40.usec      */
/* 090117 eub New parameters fixed RG with CNST29==0, RG value from RG	      */
/* 110124 eub RGMax ignored (KB10078)					      */
/******************************************************************************/
int DetRG
( const char *curdat, double RGStrt, double RGMin, double RGMax, double RGCtrl, double RGDef )
{
  static const char FktId[] = "DetRg 090117";
  char	  Message[STRING_MAXLENGTH];
  char	  TempStr[128];   /* probe name as text from 's probhd' */
  int	  TempInt;

  /* Result of function */
  int	  RetVal = 0;
  /* RG determined by RGA */
  float   RGDet;
  /* modified value of RG */
  double  RGUse;
  /* RGA might fail with too short DE */
  float   DESet;	  /* defined in dataset */
  double  DERg = 6.5;	  /* used during RGA */
  double  DEMax = 10000.; /* Max allowed DE */
  double  DEUser = 0.;	  /* defined in D31 */

  Message[0] = 0;
  TempStr[0] = 0;

#if DEMO_MODE
  {
    Proc_err(0
      ,"=== AUTOMATION PROGRESS ===\n\nDetermine RG");
    ssleep(2);
    return(0);
  }
#endif

  if (debug)
  {
    fprintf(debug,"/START\tFunction '%s' %.1f->%.0f/%.0f Corr=%.1f Def=%.0f\n"
      ,FktId,RGStrt,RGMin,RGMax,RGCtrl,RGDef);
    fflush(debug);
  }

  if ( RGCtrl < 0. )
  {
    /* Old version detected, convert dataset */
    if (debug)
      fprintf(debug,"WARNING: Convert parameters CNST29%.1f->%.1f RG->%.1f \n"
      ,RGCtrl,0.,-RGCtrl);
    STOREPAR("RG",-RGCtrl );
    STOREPAR("CNST 29",0. );
    RGCtrl = 0.;
  }

  if ( RGCtrl == 0. )
  {
    if (debug)
      fprintf(debug,"\\END\tFUNCTION '%s': RGCtlr=%.1f -> leave RG unchanged\n"
      ,FktId,RGCtrl);

    return(0);
  }

  if ( RGCtrl > 0. )
  {
    /* Try to get DE from D31 */
    FETCHPAR("D 31",&DESet);
    DEUser = DESet * 1000000.; /* D31 in sec, DE in usec */

    /* positive Value, interpreted as korrection value */
    FETCHPAR("DE",&DESet);
    DERg = DESet;

    if( DEUser == 0. )
    {
      /* Automatic adjustment, check if cryoprobe */
      /* FETCHPARS("PROBHD",TempStr); */
      (void)getProbeheadInfo(&TempInt,TempStr);
      if(DBL>0)
	fprintf(debug,"Probe='%s' [%d]\n",TempStr,TempInt);
      if( strstr(TempStr," CP")!=NULL )
      {
	DERg = DE_CRYO;
	if (debug)
	{
	  fprintf(debug,"Cryoprobe[%d], use automatic DE %.1fus\n",TempInt,DERg);
	  fflush(debug);
	}
      }
    }
    else
    {
      /* Defined via D31, check if valid */
      if( DEUser >= DESet && DEUser <= DEMax )
      {
	DERg = DEUser;
	if (debug)
	{
	  fprintf(debug,"For RGA use DE %.1fus (D31)\n",DEUser);
	  fflush(debug);
	}
      }
    }

    STOREPAR("DE",DERg);
    STOREPAR("RG",RGStrt);
    if ( AcquSave2( curdat, "rga", WAIT_TERM) )
    {
      /* Error in RGA, use default value */
      (void)sprintf(Message,"ERROR in 'RGA' use %.1f(default)",RGDef);
      RetVal = -1;
      RGUse = RGDef;
    }
    else
    {
      FETCHPAR("RG",&RGDet);
      RGUse = RGDet * RGCtrl;
      /* Check if valid */
      if (RGUse < RGMin )
      {
	RGUse = RGMin;
      }
      else
      {
	if (RGUse > RGMax )
	  RGUse = RGMax;
      }
      (void)sprintf(Message,"Use RGA = %.1f x %.2f = %.1f",RGDet,RGCtrl,RGUse);
    }

    /* Save corrected value */
    STOREPAR("RG",RGUse );
    STOREPAR("DE",DESet);

  }
  else
  {
    /* RGCtlr==0 do not change RG */
    (void)sprintf(Message,"Do not change RG");
  }

  if (debug)
  {
    fprintf(debug,"\\END\tFUNCTION %s: %s\n",FktId,Message);
    fflush(debug);
  }

  return(RetVal);
}
/* END FUNCTION DetRG *********************************************************/


/* BEGIN FUNCTION AcquSave ****************************************************/
/* If an 'AUERR' ocurrs a 'stop' and an 'ii' is executed the command repeated */
/* eub 001201 if error occurs only 'ii', no 'stop' is done		      */
/* eub 010315 2x parm. err. in debug statement / AUERR in loop not set	      */
/* eub 041102 Increase sleeptime in case of error			      */
/* eub 060109 for compatibility only, internally uses AcquSave2		      */
/******************************************************************************/
int AcquSave( const char *curdat, const char *AcquCmd )
{
  static const char FktId[] = "AcquSave 060109";

  int RetVal = 0;

  if (debug && DBL>=1)
  {
    fprintf(debug,"/START\tFUNCTION %s\n",FktId);
    fflush(debug);
  }

  /* Now call new version of function with Option WAIT_TERM */
  RetVal = AcquSave2(curdat,AcquCmd,WAIT_TERM);

  if (debug)
  {
    if (RetVal == 0)
      fprintf(debug,"<FUNCTION %s: Command '%s' done\n"
      ,FktId,AcquCmd);
    else
      fprintf(debug,"<FUNCTION %s: Command '%s' failed\n"
      ,FktId,AcquCmd);
    fflush(debug);
  }
  return(RetVal);
}
/* END FUNCTION AcquSave ******************************************************/


/* BEGIN FUNCTION AcquEnd *****************************************************/
/* eub 041109 created							      */
/* eub 041124 debugging							      */
/* eub 041214 error in debugstatement removed				      */
/******************************************************************************/
/* Usage examples							      */
/* (void)AcquEnd( curdat, "stop" );					      */
/* terminates the running acquisition with 'stop'			      */
/******************************************************************************/
int AcquEnd( const char *curdat, const char *AcquCmd )
{
  static const char FktId[] = "AcquEnd 041214";
  int	  TimeOut = 0;
  int	  TimeOutMax = MAX_ACQUREADY;
  int	  RetVal = 0;

  if (debug )
  {
    fprintf(debug,"/START\tFunction %s '%s'\n",FktId,AcquCmd);
    fflush(debug);
  }

  /* execute the stop/halt command */
  CPR_exec(AcquCmd,WAIT_TERM);
  if (debug && DBL>0)
  {
    fprintf(debug,"waiting for end of '%s'",AcquCmd);
    fflush(debug);
  }

  /* Wait till spectrometer is ready for next command */
  for( TimeOut=0; TimeOut<TimeOutMax; TimeOut++ )
  {
    if(debug && DBL>0 ){(void)fprintf(debug,"."); fflush(debug);}
    if( test_aip() )
    { ssleep(1); }
    else
    {break;}
  }
  if(debug && DBL>0) {fprintf(debug,"\n"); fflush(debug); }

  if( TimeOut == TimeOutMax )
  {
    RetVal = -1;
    if(debug)
      (void)fprintf(debug,"ERROR timeout after %dsec\n\\END\tFUNCTION %s: '%s' aborted\n"
      ,TimeOut,FktId,AcquCmd);
  }
  else
  {
    RetVal = 0;
    if(debug)
      (void)fprintf(debug,"\\END\tFUNCTION %s: '%s' after %dsec finished\n"
      ,FktId,AcquCmd,TimeOut);
  };

  if(debug) fflush(debug);
  return(RetVal);

}
/* END FUNCTION AcquEnd *******************************************************/

/* BEGIN FUNCTION AcquSave2 ***************************************************/
/* Check for running acquisition before command is executed		      */
/* if spectrometer is not ready 'ii' and 'stop' is done			      */
/* acquisition command is only executed once and only if spectrometer is ready*/
/* eub 041109 created							      */
/* eub 041221 output changed						      */
/* eub 060109 removes and resets ZGSAFTY				      */
/******************************************************************************/
int AcquSave2( const char *curdat, const char *AcquCmd, int ExecOption )
{
  static const char FktId[] = "AcquSave2 060110";

  int	TimeOut = 0;
  int	RetVal = 0;
  char ExecOptionTxt[16] = "and wait";

  char *envpnt;
  int zgsafety = 0;

  int TimeOutMax = MAX_ACQUREADY;

  if(ExecOption==0)
  {  strcpy(ExecOptionTxt,"and continue"); }

  if (debug)
  {
    fprintf(debug,"/START\tFunction %s '%s' '%s'\n"
      ,FktId,AcquCmd,ExecOptionTxt);
    fflush(debug);
  }

  /* Just WAIT for previous command to finish */
  if( test_aip() )
  {
    AUMessage("WARNING Spectrometer not ready wait");
    for( TimeOut=0; TimeOut<TimeOutMax; TimeOut++ )
    {
      ssleep(1);
      if(debug){(void)fprintf(debug,"."); fflush(debug);}
      if( !test_aip() )
      {
	if(debug) { (void)fprintf(debug,"%dsec ready",TimeOut); }
	break;
      }
    }
    if(debug) { (void)fprintf(debug,"\n"); fflush(debug); }
  }

  /* If Waiting was NOT successfull try 'ii' */
  if( TimeOut == TimeOutMax )
  {
    /* no, do 'ii' instead of acquisition */
    if(debug){(void)fprintf(debug," %dsec timeout\ntry 'ii'",TimeOut);}
    CPR_exec("ii",CONT_EX);
    for( TimeOut=0; TimeOut<TimeOutMax; TimeOut++ )
    {
      ssleep(1);
      if(debug){(void)fprintf(debug,"."); fflush(debug);}
      if( !test_aip() )
      {
	if(debug){(void)fprintf(debug,", %dsec finished\n",TimeOut+6); }
	break;
      }
    }
    if(debug) { (void)fprintf(debug,"\n"); fflush(debug); }
  }

  /* If waiting AND 'ii' were NOT successfull try to 'stop' */
  if( TimeOut == TimeOutMax || AUERR )
  {
    if(debug)
    {
      (void)fprintf(debug," %dsec timeout or AUERR\ntry 'stop'",TimeOut);
      fflush(debug);
    }
    CPR_exec("stop",CONT_EX);
    for( TimeOut=0; TimeOut<TimeOutMax; TimeOut++ )
    {
      ssleep(1);
      if(debug){(void)fprintf(debug,"."); fflush(debug);}
      if( !test_aip() )
      {
	if(debug){(void)fprintf(debug,", %dsec finished\n",TimeOut); fflush(debug); }
	break;
      }
    }
  }

  /* If all o.k. try acquisition command */
  if( TimeOut < TimeOutMax && !AUERR )
  {
    if(DBL>0)
    {
      (void)fprintf(debug,"Run command '%s' '%s'\n",AcquCmd,ExecOptionTxt);
      fflush(debug);
    }
    /* Remember ZG-safety and switch off if necessary */
    envpnt = getenv("UXNMR_SAFETY");
    if(envpnt != NULL)
    {
      if(strcasecmp(envpnt, "on") == 0)
      {
	zgsafety = 1;
	CPR_exec("env unset UXNMR_SAFETY", WAIT_TERM);
	if(debug)
	{
	  (void)fprintf(debug,"UXNMR_SAFETY unset ");
	  fflush(debug);
	}
      }
    }
    CPR_exec(AcquCmd,ExecOption);
    /* Reset original status of ZGSAFETY */
    if(zgsafety == 1)
    {
      CPR_exec("env set UXNMR_SAFETY=ON", WAIT_TERM);
      if(debug)
      {
	(void)fprintf(debug," ON\n");
	fflush(debug);
      }
    }
  }

  if( AUERR || TimeOut == TimeOutMax )
  {
    RetVal = -1;
  }

  /* document results */
  if (debug)
  {
    if (RetVal == 0 )
      fprintf(debug,"\\END\tFUNCTION %s: done\n",FktId);
    else
      fprintf(debug,"\\END\tFUNCTION %s: failed!!\n",FktId);
    fflush(debug);
  }

  return(RetVal);
}
/* END FUNCTION AcquSave2 *****************************************************/


/* FUNCTION AcquRun 2.0 991230 ************************************************/
/* Checks if 'zg' is running by doing 'tr' until NS changes		      */
/* ATTENTION, 2s NS is changed, FID is overwritten			      */
/* 001023 tested, debug changed						      */
/******************************************************************************/
int AcquRun( const char *curdat, int TimeOutMax )
{
  static const char FktId[] = "AcquRun 001013";
  int TimeOut = 0;
  int NSAkt,NSLast;
  int WaitTime = 1;

  if (debug)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fprintf(debug," Check for %dsec in steps of %dsec if 'tr' increases NS\n"
      ,TimeOutMax,WaitTime);
    fflush(debug);
  }

  FETCHPARS("NS",&NSLast);
  NSAkt = NSLast;
  if(DBL >= 3)
    fprintf(debug,"NS = %d",NSLast);

  while ( NSLast == NSAkt )
  {
    CPR_exec("tr",CONT_EX);
    ssleep(WaitTime);
    FETCHPARS("NS",&NSAkt);

    TimeOut++;
    if(DBL >= 3)
    {
      fprintf(debug,"|%d",NSAkt);
      fflush(debug);
    }

    if ( TimeOut > TimeOutMax )
    {
      /* Ohne Erfolg! */
      TimeOut= -TimeOut;
      if(DBL >= 3)
	fprintf(debug,"no change!\n");
      break;
    }
  }

  if (debug)
  {
    if(DBL >= 3) fprintf(debug,"\n");
    if( TimeOut <= 0 )
    {
      fprintf(debug," NO Acquisition detected after %dsec\n",-TimeOut);
    }
    else
    {
      if(DBL >= 3)
	fprintf(debug,"changed!\n");
      fprintf(debug," Acquisition DETECTED after %dsec (NS %d -> %d)\n"
	,TimeOut,NSLast,NSAkt);
    }
    fprintf(debug,"\\END\tFUNCTION '%s' -> (%d)\n",FktId,TimeOut);
    fflush(debug);
  }

  return( TimeOut );
}
/******************************************************************************/


/* FUNCTION TrN 991230 ********************************************************/
/* Executes a "tr" until the desired "NSSet" are on the disk		      */
/* "tr" is executed every second until only 2 scans are to do, then "tr" is   */
/* executed without delay						      */
/******************************************************************************/
int TrN( const char *curdat, int NSSet, float TimeOutMaxSet )
{
  int RetVal;
  double TimeOut = 0.;
  double TimeOutMax;
  int NSAkt = 0;

  if (DBL >= 1)
  {
    fprintf(debug,"/START\tFUNCTION 'TrN 991230'");
    fflush(debug);
  }

  TimeOutMax = TimeOutMaxSet;

  /* Get actual number of scans */
  FETCHPARS("NS",NSAkt);

  /* Wait for desired NS or until TimeOut occurs */
  while ( (NSAkt < NSSet) && (TimeOut <= TimeOutMax) )
  {
    if( (NSAkt-NSSet) >= 2 )
    {
      /* slow scanning with 1sec steps */
      ssleep(1);
      TimeOut += 1.;
    }
    else
    {
      /* fast scanning with NO delay */
      TimeOut += 0.01;
    }
    CPR_exec("tr",WAIT_TERM);
    FETCHPAR("NS",NSAkt);
  }

  if ( NSAkt == NSSet )
  {
    /* desired NS were transferred */
    if(DBL>=1)
      fprintf(debug,"Transferred NS %d\n",NSAkt);
    RetVal = 0;
  }
  else
  {
    if( NSAkt > NSSet )
    {
      /* experiment runs to fast */
      if(DBL>=1)
	fprintf(debug
	,"ERROR Correct NS %d missed, done with NS %d\n"
	,NSSet,NSAkt);
      RetVal = -1;
    }
    else
    {
      /* probably timeout reached */
      if(DBL>=1)
	fprintf(debug
	,"ERROR Timeout (%.2f) occured done with NS %d\n"
	,TimeOut,NSAkt);
      RetVal = -1;
    }
  }

  if(DBL>=1)
  {
    fprintf(debug,"\\END\tFUNCTION 'TrN'\n");
    fflush(debug);
  }

  return RetVal;
}
/* END FUNCTION TrN ***********************************************************/


/* FUNCTION TimePerScan *******************************************************/
/* Calculates the timeconsuption per scan in seconds			      */
/* Return as result of function does not work				      */
/******************************************************************************/
int TimePerScan( const char *curdat , double *TimePerScanInt )
{
  static const char FktId[] = "TimePerScan 041221";

  int ExpTime, NSSet, DSSet, TD1Set, TotalScans;
  int ParmodeSet = 0;
  int	TD0Set;

  if (DBL>0)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* Get parameters from orig exp */
  FETCHPAR("NS",&NSSet);
  FETCHPAR("DS",&DSSet);
  FETCHPAR("TD0",&TD0Set);
  FETCHPAR("PARMODE",&ParmodeSet);
  if ( ParmodeSet == 0 )
  {
    TD1Set = 1;
  }
  else
  {
    FETCHPAR1("TD",&TD1Set);
  }
  TotalScans = DSSet + (NSSet * TD1Set);

  /* for backward compatibility calculate without TD0 loop*/
  STOREPAR("TD0",1);
  /* Total expt time incl. DS in sec */
  /* XWINNMR ExpTime = CalcExpTime( curdat ); */
  ExpTime = CalcExpTime(); /* TOPSPIN */

  STOREPAR("TD0",TD0Set);

  *TimePerScanInt = (double)ExpTime/(double)TotalScans;

  if (debug)
  {
    fprintf(debug
      ,"<FUNCTION '%s'->(%d) %dsec/(%dDS + %d*%dNS)=%.2fsec/scan\n"
      ,FktId,0,ExpTime,DSSet,TD1Set,NSSet,*TimePerScanInt);
    fflush(debug);
  }

  return(0);
}
/* END FUNCTION TimePerScan ***************************************************/



/* FUNCTION ZgSino ************************************************************/
/* runs the acqusition on expno 999					      */
/* 001015 mod High DS -> first AcquRun failed! double SinoAkt -> float	      */
/* 090807 eub Datastructure without user				      */
/******************************************************************************/
int ZgSino
(const char *curdat, int NSMin, int NSMax, double SinoMin, double SinoMax )
{
  static const char FktId[] = "ZgSino 090807";

  int NSAkt,NSNext;
  float SinoAkt;
  int DSToDo, DSSet;
  int ExpnoMain;
  int TempInt;

  /*EUBC NS are always doubled */
  int NSFactor = 2;

  /*EUBC time for fast scanning for next NS */
  int FastScanTime = 16;

  /*EUBC Time per 1 NS */
  double TimeRes;

  int NextWait;
  int StepNr;
  int TimeOut, TimeOutMax;

  if (debug)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  FETCHPAR("PARMODE",&TempInt);
  if (TempInt > 0)
  {
    if (debug)
      fprintf(debug,"ERROR 'ZgSino' not implemented for 2D experiments\n");
    ABORT;
  }

  /* Get parameters from experiment */
  FETCHPAR("DS",&DSSet);

  /* Change dataset */
  ExpnoMain = expno;

  if ( 999 != expno )
  {
    if(debug)
      fprintf(debug,"Running on dataset %s %d %d '%s'\n",name,999,procno,disk);
    WRPA(name,999,procno,disk,user);
    DATASET(name,999,procno,disk,user);
  }

  /* TimeRes = Timeresolution per scan as float value */
  (void)TimePerScan( curdat, &TimeRes );

  /* Anfangs keine Scans, keine Dummyscans */
  DSToDo = DSSet;
  NSAkt = 0;

  /* Erster Schritt minimale anzahl von scans */
  /* NSNext will be check against NSMax */
  if ( NSMax < NSMin )
  {
    if(debug)
      fprintf(debug,"WARNING NSMin %d < NSMax %d\n"
      ,NSMin,NSMax);
    NSMin = NSMax;
  }
  NSNext = NSMin;
  StepNr = 1;

  /* Factor 2 for error in time calculation */
  TimeOutMax = 2 * FastScanTime;

  if(debug)
  {
    fprintf(debug,"PARAMETERS\n");
    fprintf(debug," NSMin %d NSMax %d  SINOMin %.1f SINOMax %.f\n"
      ,NSMin,NSMax,SinoMin,SinoMax);
    fprintf(debug,"Timing         : %.1fsec/(%d NS + %d DS) = %.2fsec/scan\n"
      ,TimeRes*((double)DSSet+(double)NSMax),NSMax,DSSet,TimeRes);
    fprintf(debug,"Timeout waiting: %dsec\n",TimeOutMax);
    fprintf(debug,"Fast Scanning  : %dsec\n",FastScanTime);
    fflush(debug);
  }


  /* Start experiment */
  STOREPARS("NS",NSAkt);
  AcquSave( curdat, "ii" );
  CPR_exec("zg",CONT_EX);

  while ( NSAkt < NSMax )
  {
    if ( NSNext > NSMax )
    {
      NSNext = NSMax;
    }

    if (debug)
    {
      fprintf(debug,"\nStep %2d  %dDS %dNS -> %dDS %dNS\n"
	,StepNr,DSSet - DSToDo,NSAkt,DSSet,NSNext);
      fflush(debug);
    }

    /* Must JUST wait, during DS AcquRun does not work */
    if (debug)
    {
      fprintf(debug,"Wait %dsec for %dDS\n",(int)(TimeRes*DSToDo),DSToDo);
    }
    ssleep((int)(TimeRes*DSToDo));

    /*EUBC Wartezeit in ganzen Sekunden */
    NextWait = (int)(TimeRes * (double)( NSNext - NSAkt ) - (double)FastScanTime);

    if ( NextWait > 0 )
    {
      while( NextWait > 60 + FastScanTime )
      {
	if (debug)
	{
	  fprintf(debug,"Wait 60sec test %dsec (estimated expt. for step %d = %dsec)\n"
	    ,2*FastScanTime,StepNr,NextWait+FastScanTime);
	  fflush(debug);
	}

	/* Wait only 60 sec */
	ssleep(60);

	/* Check for 30sec if acqu is still running */
	TempInt = AcquRun( curdat, 2 * FastScanTime );

	if ( TempInt >= 0 )
	{
	  /* Acqu is running so reduce Waittime */
	  NextWait = NextWait - TempInt - 60;
	  if (DBL >= 2)
	  {
	    fprintf(debug
	      ,"NextWait reduced to zu %dsec\n",NextWait);
	  }
	}
	else
	{
	  /* Nothing happened during last 15sec */
	  if (debug)
	  {
	    fprintf(debug,"Acqusition not running, ABORT\n");
	  }
	  ABORT;
	}
      }
      /* Wait till end is nearly reached */
      if (DBL >= 2)
      {
	fprintf(debug,"Wait %dsec, scan for %dsec\n",NextWait,TimeOutMax);
	fflush(debug);
      }
      ssleep(NextWait);
    }
    else
    {
      /* Step relatively short, scan immediately */
      if (DBL >= 2)
	fprintf(debug,"Time to short, scan immediately\n"); fflush(debug);
    }


    /* Exp terminates soon, check every second */
    if (debug)
    {
      fprintf(debug,"Scan start\n"); fflush(debug);
    }

    /* Reset timeout for every fastscan */
    TimeOut = 0;
    while( NSAkt < NSNext )
    {
      CPR_exec("tr",CONT_EX);
      ssleep(1);
      FETCHPARS("NS",&NSAkt);
      if (DBL >= 2)
      {
	fprintf(debug,"%d|",NSAkt);
	fflush(debug);
      }

      TimeOut++;
      if ( TimeOut > TimeOutMax )
      {
	if (debug)
	{
	  fprintf(debug,"Timeout! ABORT\n");
	  fflush(debug);
	}
	/* Auf keinen Fall "stop", User hat vielleicht stop/halt */
	/* gemacht und bereits anderes Experiment gestartet  */
	ABORT;
      }
    }

    if (debug)
    {
      fprintf(debug
	," NS %d reached after scanning %dsec\n",NSAkt,TimeOut);
      fflush(debug);
    }

    AUMessage("\nProcess spectrum for sino\n");
    EM;
    FT;
    APK0;

    XAU("lcsino", "");
    FETCHPARS("SINO",&SinoAkt);

    /* Save data to original dataset */
    if ( ExpnoMain != expno )
    {
      WRPA(name,ExpnoMain,procno,disk,user);
    }


    /* Highes priority: Terminate if NS are reached */
    if ( NSAkt >= NSMax )
    {
      if (debug)
	fprintf(debug,"NS reached\nStop after %d scans\n",NSAkt);

      /* When NSAkt = NSMAx the acquisition should be over! */
      /* For security do an ii */
      AcquSave( curdat, "ii");

      return(0);
    }
    else
    {
      if(debug)
	fprintf(debug,"NS = %d < %d NSMax\n",NSAkt,NSMax);
    }

    if ( SinoAkt >= SinoMax )
    {
      /* STOP the requested SINO is reached */
      if (debug)
      {
	fprintf(debug
	  ,"SINO=%.1f after NS=%d\nRequested SINO %.1f\n"
	  ,SinoAkt,NSAkt,SinoMax);
	fprintf(debug,"\nTerminate acquisition\n");
	fflush(debug);
      }
      (void)AcquSave( curdat, "stop");

      return(0);
    }
    else
    {
      if(debug)
	fprintf(debug,"SINO = %.1f < %.1f = SinoMax\n",SinoAkt,SinoMax);
    }

    if ( SinoAkt < SinoMin )
    {
      /* ABORT there is only NOISE in the spectrum */
      if ( debug )
      {
	fprintf(debug
	  ,"SINO=%.1f after NS=%d\nBelow minimum SINO of %.1f\n"
	  ,SinoAkt,NSAkt,SinoMin);
	fprintf(debug,"\nTerminate acquisition\n");
	fflush(debug);
      }
      AcquSave( curdat, "stop");

      return(-1);
    }
    else
    {
      if(debug)
	fprintf(debug,"SINO = %.1f > %.1f = SinoMin\n",SinoAkt,SinoMin);
    }

    if(debug)
      fflush(debug);


    /* Acquisition continues, so prepare next step */

    /* Get number of scans after Processing */
    TimeOut = 0;
    TempInt = NSAkt;
    /* Check that 'tr' really reads new NS, WAIT_TERM does not work */
    while ( TempInt == NSAkt )
    {
      CPR_exec("tr",CONT_EX);
      ssleep(1);
      FETCHPARS("NS",&NSAkt);

      TimeOut++;
      if ( TimeOut > TimeOutMax )
      {
	if ( debug )
	{
	  fprintf(debug,"No scans after %d sec\n",TimeOut);
	}
	ABORT;
      }
    }


    /* Next number of scans */
    NSNext = NSFactor * NSNext;

    if ( StepNr == 1 )
    {
      DSToDo = 0;
    }

    StepNr++;
  }

  if (debug)
  {
    fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return 0;
}
/* End Function ZgSino ********************************************************/


/* FUNCTION ZgSino2 ***********************************************************/
/* runs the acqusition on expno 999					      */
/* 041109 eub uses acquisition loop					      */
/* 080622 eub checks every 10sec for acqu running to react on userinteraction */
/******************************************************************************/
int ZgSino2
(const char *curdat, int NSMin, double SinoMin, double SinoMax )
{
  static const char FktId[] = "ZgSino2 080622";

  char ErrMsg[PATH_MAX];

  int NSAkt;
  int NSMax;
  int NSNext;
  float SinoAkt = 0.;
  int DSSet;
  int TempInt;

  /*EUBC Time per 1 NS */
  double TimeRes;
  int	NSInc; /* Defined via NS in the dataset */
  int	NSIncTime; /* TimeRequired for acquisition of NSInc Scans */
  int	NSLast;
  int	TD0Set;
  int	SleepTime = 1;
  int	i;

  int TimeOut, TimeOutMax;

  if (debug)
  {
    fprintf(debug,"/START\tFunction '%s' start from NS=%d to get Sino %.1f to %.1f\n"
      ,FktId,NSMin,SinoMin,SinoMax);
    fflush(debug);
  }

  FETCHPAR("PARMODE",&TempInt);
  if (TempInt > 0)
  {
    sprintf(ErrMsg,"ERROR 'ZgSino' not implemented for 2D experiments\n");
    goto AbortProgram;
  }

  /* Get parameters from experiment total NS must be setup via NS and TDO */
  FETCHPAR("DS",&DSSet);
  FETCHPAR("NS",&NSInc);
  FETCHPAR("TD0",&TD0Set);
  NSMax = (int)(TD0Set * NSInc);
  NSLast = 0;
  NSAkt = 0;

  if(NSMin < NSInc)
  {
    if(debug)
    {
      fprintf(debug,"WARNING: min. NS must be >Increment, changed from %d to %d\n",NSMin,NSInc);
      fflush(debug);
    }
    NSMin = NSInc;
  }

  /* TimeRes = Timeresolution per scan as float value */
  (void)TimePerScan( curdat, &TimeRes );
  SleepTime = (int)(TimeRes + 1.);

  /* Continuous delay for first wait is time for DS and 80% of NSInc */
  NSIncTime = (int)(TimeRes*(double)DSSet + 0.8*TimeRes*(double)NSMin );
  /* Scanning time is from 80% to 120% of NSInc time plus 12sec for spect startup */
  TimeOutMax = (int)((double)MAX_ACQUREADY + 0.4*TimeRes*(double)NSMin);
  NSNext = NSMin;

  if(DBL>0)
  {
    (void)fprintf(debug,"Acquire NSMin %d (%dsec) TD0Set %d x NSInc %d = NSMax %d\n"
      ,NSMin,NSIncTime+TimeOutMax,TD0Set,NSInc,NSMax); }

  /* start acquisition */
  if( AcquSave2(curdat,"zg",CONT_EX) )
  {
    sprintf(ErrMsg,"ERROR: Acquisition could not be started ... ABORT\n");
    goto AbortProgram;
  }

  STOREPARS("NS",NSAkt);
  do
  {
    /* Wait until next NS are exspected */
    if (debug)
    {
      fprintf(debug,"\nWait %dsec before checking for NS=%d\n",NSIncTime,NSNext);
      fflush(debug);
    }

    /* Wait n x 1sec, every 10sec check if acquisition is still running */
    for( i=0; i<NSIncTime; i++)
    {
      ssleep(1);
      if( !(i % 10) && !test_aip() )
      {
	sprintf(ErrMsg,"ERROR: No acquisition while waiting for NS %d ... ABORT\n",NSNext);
	goto AbortProgram;
      }
    }

    /* Check in 1sec steps if exspected NS are on the disk */
    if (DBL>0)
    {
      fprintf(debug,", scan %dsec", TimeOutMax);
      fflush(debug);
    }
    TimeOut = 0;
    while ( TimeOut < TimeOutMax )
    {
      ssleep(SleepTime);
      TimeOut = TimeOut + SleepTime;

      FETCHPARS("NS",&NSAkt);
      if( NSAkt >= NSNext )
      {
	/* New NS found */
	if(debug)
	{
	  fprintf(debug,"Found NS=%d after %d+%dsec check SINO\n"
	    ,NSAkt,NSIncTime,TimeOut);
	  fflush(debug);
	}
	NSNext = NSAkt + NSInc;

	EM;
	FT;
	APK0;

	XAU("lcsino", "");
	FETCHPARS("SINO",&SinoAkt);
	break;
      }
      else
      {
	/* No new NS found, check if zg is still running */
	if( !test_aip() )
	{
	  sprintf(ErrMsg,"ERROR: No acquisition after while waiting for NS %d ... ABORT\n",NSAkt);
	  goto AbortProgram;
	}
	else
	{ if(DBL>0){fprintf(debug,"."); fflush(debug);} }
      }
    }

    /* Check if SINO is reached or too low */
    if(SinoAkt < SinoMin )
    {
      if(debug)
      {
	fprintf(debug
	  ,"\nABORTING Acquisition\nSINO %.1f:1 with NS %d is below Min %.1f\n"
	  ,SinoAkt,NSAkt,SinoMin);
	fflush(debug);
      }

      /* STOP, do not store additional scans, don't want odd NS */
      AcquEnd(curdat,"stop");
      break;
    }
    if(SinoAkt >= SinoMax )
    {
      if(debug)
      {
	fprintf(debug
	  ,"TERMINATING Acquisition\nSINO %.1f:1 with NS %d has reached Max %.1f\n"
	  ,SinoAkt,NSAkt,SinoMax);
	fflush(debug);
      }
      /* STOP, do not store additional scans, don't want odd NS */
      AcquEnd(curdat,"stop");
      break;
    }

    /* Reset Scantime to 80% of acquisition time */
    NSIncTime = (int)(0.8*TimeRes*NSInc);
    /* scan +/-20% around exspected time */
    TimeOutMax = (int)(0.4*TimeRes*NSInc);
  }
  while( NSAkt < NSMax);

  goto EndProgram;

AbortProgram:
  if (debug)
  {
    fprintf(debug,"\n\\%s\tFUNCTION '%s'\n",ErrMsg,FktId);
    fflush(debug);
  }
  return -1;

EndProgram:
  if (debug)
  {
    fprintf(debug,"\n\\END\tFUNCTION '%s' SINO %.1f:1 @ NS %d\n",FktId,SinoAkt,NSAkt);
    fflush(debug);
  }
  return 0;
}
/* End Function ZgSino2 *******************************************************/


/* FUNCTION check_autoshim ****************************************************/
/* 080910 eub Remove message with Proc_err				      */
/******************************************************************************/
int check_autoshim(void)
{
  int errcode = 0;
  char command[256];
  const char *exchangeFilePath;
  const char *options[4];
  const char *result;
  int status = 0;

  exchangeFilePath = getCPR_exchange_file_args(options);

  sprintf(command,"autoshim %s %s",options[0],options[1]);

  (void)unlink(exchangeFilePath);

  /* import result from file */
  errcode = CPR_exec(command, WAIT_TERM);
  if ((result = getCPR_exchange_message(exchangeFilePath)) != NULL)
  {
    char *ptr = strchr(result,'=');
    const char varname[] = "AUTOSHIM";
    int len = sizeof(varname) -1;
    (void)unlink(exchangeFilePath);
    if( DBL>0 )
      fprintf(debug,"File '%s'\nContains text '%s'\n",exchangeFilePath,result);
    if (ptr && strncmp(result,varname,len) == 0)
    {
      char stat_str[8];
      ptr++;
      sscanf(ptr,"%s",stat_str);
      if (strcmp(stat_str,"ON") == 0)
	status = 1;
    }
    else
    {
      if(debug)
	fprintf(debug,"syntax error in autoshim answer:\n%s\n\t%s\n",
	command,result);
      status =	-1;
    }
  }




  if(debug)
  {
    fprintf(debug,"<FUNCTION\tcheck_autoshim 041126: Autoshim is %d\n",status);
    fflush(debug);
  }
  return status;
}
/* END FUNCTION check_autoshim ************************************************/


/* FUNCTION LockInfo **********************************************************/
/* Reports the status of the lock					      */
/* 080911 Extracted from AU program, LockNoise not yet evaluated	      */
/******************************************************************************/
int LockInfo(int *LockStatusExt, double *LockLevelExt, double *LockNoiseExt)
{
  static const char FktId[] = "LockInfo 080911";
  char Message[PATH_MAX] = "";

  int errcode = 0;		/* used to hold return values */
  char command[256];		/* buffer for cpr command string */
  const char *exchangeFilePath; /* pointer for function return value */
  const char *options[4];		/* array for  getCPR_exchange_file_args()*/
  const char *result;	/* used to hold return of getCPR_exchange_message()*/

  char *ptr;
  double LockLevel = 0.;
  double LockNoise = 0.;
  char LockStatusStr[8] = "";	  /* "locked", "unlocked", "hold" */
  int  LockStatus = -1;

  if (debug)
  {
    fprintf(debug,"/START\tFunction '%s'\n",FktId);
    fflush(debug);
  }

  /* first get the communication filename and additional options  */
  /* needed as arguments for the cpr commands			*/
  exchangeFilePath = getCPR_exchange_file_args(options);
  /*  the return value is the full pathname to the communication  */
  /*  file, the option array return 2 pointer to the neccessary   */
  /*  arguments for the cpr commands(if the summport this feature)*/

  /* build cpr command string					*/
  /*  (the 2 options are inserted between command and first	*/
  /*   regular argument)						*/
  sprintf(command,"getlock %s %s 1",options[0],options[1]);

  /* remove old file; ignore error if not existing */
  (void)unlink(exchangeFilePath);

  /* execute command */
  errcode = CPR_exec(command, WAIT_TERM);

  /* import result from file */
  if (errcode || (result = getCPR_exchange_message(exchangeFilePath)) == NULL)
  {
    sprintf(Message,"Error reading input file\n'%s'",exchangeFilePath);
    goto AbortProgram;
  }

  (void)unlink(exchangeFilePath);  /* remove file not needed anymore */

  /* show full answer: */
  if( DBL>0 )
    fprintf(debug,"File '%s'\nContains text '%s'\n",exchangeFilePath,result);

  /* do reverse search for last equal sign */
  ptr = strrchr(result,'=');
  if (ptr)
  {
    sprintf(LockStatusStr,++ptr);
    if( !strcmp(LockStatusStr,"locked") )
      LockStatus = 1;
    else if( !strcmp(LockStatusStr,"unlocked") )
      LockStatus = 0;
    else if( !strcmp(LockStatusStr,"pending") )
      LockStatus = 2;
  }
  else
  {
    sprintf(Message,"syntax error in getlock answer:\n%s\n\t%s",
      command,result);
    goto AbortProgram;
  }

  /* search the first equal sign and read the value into LockLevel */
  ptr = strchr(result,'=');
  if (ptr)
  {
    ptr++;	/* increment the pointer to the character beyond the equal sign */
    sscanf(ptr,"%lf",&LockLevel);
  }
  else
  {
    sprintf(Message,"syntax error in getlock answer:\n%s\n\t%s",
      command,result);
    goto AbortProgram;
  }
  /* Locknoise not yet implemented */
  LockNoise = 0.;

  if( LockLevelExt!=NULL )
    *LockLevelExt = LockLevel;
  if( LockStatusExt!=NULL )
    *LockStatusExt = LockStatus;
  if( LockNoiseExt!=NULL )
    *LockNoiseExt = LockNoise;
  if (debug)
  {
    fprintf(debug,"\\END\tFUNCTION '%s'->%d %s Level=%5.3f\n"
      ,FktId,LockStatus,LockStatusStr,LockLevel);
    fflush(debug);
  }

  return LockStatus;

AbortProgram:
  if (debug)
  {
    fprintf(debug,"%s\\END\tFUNCTION '%s'\n",Message,FktId);
    fflush(debug);
  }
  return -1;
}
/* END FUNCTION LockInfo ******************************************************/

/* FUNCTION msino *************************************************************/
/* Finds the highest SINO multiple regions				      */
/* Sino regions must be prepared as array [Start,End,Start,End,...]	      */
/* The original values of SIGF1, SIGF2, NOISF1, NOISF2 are restored	      */
/* 001013 double Reg							      */
/* 010521 Check sino twice also after NM, debug changed			      */
/* 080902 Store result to 2S SINO					      */
/******************************************************************************/
int msino( const char *curdat, int AnzReg, double *Reg, double *SINOBest )
{
  static const char FktId[] = "msino 080902";
  char	Message[PATH_MAX] = "";

  float SIGF1Set = 10.;
  float SIGF2Set =  0.;
  int	RegNr = 0;
  float SINOAkt;
  float SINOIntBest = 0.;
  int	UseNM = 0;
  float TempFloat = 0.;

  if (debug && DBL>=1)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n%d regions",FktId,AnzReg);
    for ( RegNr=0; RegNr<AnzReg; RegNr++ )
    {
      fprintf(debug," [%.3f - %.3f]",*(Reg + 2*RegNr),*(Reg + 2*RegNr+1));
    }
    fprintf(debug,"\n");
    fflush(debug);
  }

  /* Save original SIGFs */
  FETCHPAR("SIGF1",&SIGF1Set);
  FETCHPAR("SIGF2",&SIGF2Set);

  /* Check SINO for each region */
  for ( RegNr=0; RegNr<AnzReg; RegNr++ )
  {
    /* Set SIGFs for actual region */
    STOREPAR("SIGF1", *(Reg + 2*RegNr) );
    STOREPAR("SIGF2", *(Reg + 2*RegNr+1) );

    /* Determine SINO AUERR is not set by 'sino' */
    CPR_exec("sino real noprint",WAIT_TERM);
    FETCHPARS("SINO",&SINOAkt);
    if ( DBL>=2 )
      fprintf(debug,"%d %.1f:1 ",RegNr,SINOAkt);
    if ( SINOAkt > SINOIntBest )
    {
      SINOIntBest = SINOAkt;
    }
  }

  /* invert spectrum to check if phase was wrong */
  NM;


  /* Check SINO again for each region */
  for ( RegNr=0; RegNr<AnzReg; RegNr++ )
  {
    /* Set SIGFs for actual region */
    STOREPAR("SIGF1", *(Reg + 2*RegNr) );
    STOREPAR("SIGF2", *(Reg + 2*RegNr+1) );

    /* Determine SINO AUERR is not set by 'sino' */
    CPR_exec("sino real noprint",WAIT_TERM);
    FETCHPARS("SINO",&SINOAkt);
    if ( DBL>=2 )
      fprintf(debug,"%d %.1f:1 ",RegNr,SINOAkt);
    if ( SINOAkt > SINOIntBest )
    {
      SINOIntBest = SINOAkt;
      /* At least ONE value better in NM spectrum */
      UseNM = 1;
    }
  }

  /* Restore original spectrum, SIGFs and NOISFs */
  STOREPAR("SIGF1",SIGF1Set);
  STOREPAR("SIGF2",SIGF2Set);
  STOREPARS("SINO",SINOIntBest);
  if( !UseNM )
  {
    /* original phase correction was o.k. */
    /* apply 2nd NM to restore the orignal spectrum */
    NM;
  }
  else
  {
    /* keep inverted spectrum */
    /* adjust PHC0 so that next FP produces correct phase */
    strcpy(Message,"(inv. spectrum) ");
    FETCHPARS("PHC0",&TempFloat);
    if( TempFloat > 180. )
    {
      STOREPAR("PHC0",TempFloat-180.);
      STOREPARS("PHC0",TempFloat-180.);
    }
    else
    {
      STOREPAR("PHC0",TempFloat+180.);
      STOREPARS("PHC0",TempFloat+180.);
    }
  }

  /* Return Result */
  if ( AnzReg > 0 )
  {
    *SINOBest = (double)SINOIntBest;
    sprintf(Message,"%s%.1f:1 in %d region(s) in %.3f - %.3fppm"
      ,Message,*SINOBest,AnzReg,*Reg,*(Reg + 2*(AnzReg-1) +1));
  }
  else
  {
    *SINOBest = -1.;
    strcat(Message,"No valid regions for SINO");
  }

  if( debug )
  {
    fprintf(debug,"<FUNCTION %s: %s\n",FktId,Message);
    fflush(debug);
    return(0);
  }

  if( *SINOBest == -1. )
    return(-1);
  else
    return(0);

}
/* END FUNCTION msino *********************************************************/


/* FUNCTION ReadFrqOn *********************************************************/
/* Trys to get presaturation positions from transmitter frequencies SFO1..8   */
/* SFO<n> is considered as suppression frequency if			      */
/* -NUC is NOT "off"  - Value of SFO<n> is within SFO1 +/- SW		      */
/* The returned values are corrected by SR				      */
/* Values can be returnd in 'Hz' and/or in 'ppm'			      */
/* If an ARRAYs is NULL, the value is not returned			      */
/* Currently does NOT WORK for AMX/ARX					      */
/* 001015 eub Works for AMX/ARX						      */
/* 001221 eub ARRAY size 8->9, sprinft->fprintf, debug corrected	      */
/* 050827 eub content replaced by 'ReadFrqOn_2' with fixed mode -2=acqu2s     */
/******************************************************************************/
int ReadFrqOn( const char *curdat, float SR, double *Frq, double *FrqP )
{
  static const char FktId[] = "ReadFrqOn 050827";

  if (debug)
  {
    fprintf(debug,"REPLACED Function '%s' ->'ReadFrqOn_2'\n",FktId);
    fflush(debug);
  }

  return(ReadFrqOn_2( curdat, SR, Frq, FrqP, -2 ));
}
/* END FUNCTION ReadFrqOn *****************************************************/


/* FUNCTION ReadFrqOn_2 *******************************************************/
/* 001221 eub Identical to ReadFrqOn SFO from 2,2S,1,1s parameters	      */
/* 080623 eub Support of A*X and D*X ended				      */
/******************************************************************************/
int ReadFrqOn_2( const char *curdat, float SR, double *Frq, double *FrqP, int Mode )
{
  static const char FktId[] = "ReadFrqOn_2 080623";

  /* Mode 2: acqu2  -2: acqu2S	1:acqu	-1 acquS */


  double TempDouble;
  char TempStr[PATH_MAX];
  double BF1;
  int FrqAnz = 0;
  char SFOName[9];
  /* For debugging */
  double SW;
  /* First frequency */
  double FFrq;
  /* different for AVANCE and ARX/AMX */
  char	ChnN[9][9];
  int	ChnNrMax = 8;
  int	ChnNr;
  int	FrqNr;

  if (debug)
  {
    fprintf(debug,"/START Function '%s'\n",FktId);
    fflush(debug);
  }

  /* BF1 -> For PPM calculation */
  /* SW -> Must check if O's are in sweepwidth */
  if (DBL >= 2)fprintf(debug," Get PARAMETERS with ");
  switch ( Mode )
  {
  case 1:
    if (DBL >= 2)fprintf(debug,"'FETCHPAR1(..'\n");
    FETCHPAR1("BF1",&BF1);
    FETCHPAR1("SW",&SW);
    break;
  case -1:
    if (DBL >= 2)fprintf(debug,"FETCHPAR1S(..\n");
    FETCHPAR1S("BF1",&BF1);
    FETCHPAR1S("SW",&SW);
    break;
  case 2:
    if (DBL >= 2)fprintf(debug,"FETCHPAR(..\n");
    FETCHPAR("BF1",&BF1);
    FETCHPAR("SW",&SW);
    break;
  default:
    if (DBL >= 2)fprintf(debug,"FETCHPARS(..\n");
    FETCHPARS("BF1",&BF1);
    FETCHPARS("SW",&SW);
  }

  if (DBL >= 2)
    fprintf(debug," PARAMETERS BF1 %.6fMHz  SW %.2fppm SR %.2fHz\n"
    ,BF1,SW,SR);

  for( ChnNr=1; ChnNr<=8; ChnNr++ )
  {
    sprintf(ChnN[ChnNr],"NUC%d",ChnNr);
  }

  /* Special treatment of O1 */
  /* Cannot use *Frq, because might be NULL */
  switch ( Mode )
  {
  case 1:
    FETCHPAR1(ChnN[1],TempStr);
    FETCHPAR1("O1",&FFrq);
    break;
  case -1:
    FETCHPAR1S(ChnN[1],TempStr);
    FETCHPAR1S("O1",&FFrq);
    break;
  case 2:
    FETCHPAR(ChnN[1],TempStr);
    FETCHPAR("O1",&FFrq);
    break;
  default:
    FETCHPARS(ChnN[1],TempStr);
    FETCHPARS("O1",&FFrq);
  }

  FFrq = FFrq - SR;
  if (DBL >= 2)
    fprintf(debug,"SFO1 = '%s' %.2fHz %.3fppm\n"
    ,TempStr,FFrq,FFrq/BF1);

  /* Assign return values */
  if ( Frq != NULL )  *Frq = FFrq;
  if ( FrqP != NULL ) *FrqP = (FFrq / BF1);
  FrqAnz = 1;

  /* Read values from SFO2..SFO8 */
  for ( ChnNr=2; ChnNr<=ChnNrMax; ChnNr++ )
  {
    sprintf(SFOName,"SFO%d",ChnNr);

    switch ( Mode )
    {
    case 1:
      FETCHPAR1(ChnN[ChnNr],TempStr);
      FETCHPAR1(SFOName,&TempDouble);
      break;
    case -1:
      FETCHPAR1S(ChnN[ChnNr],TempStr);
      FETCHPAR1S(SFOName,&TempDouble);
      break;
    case 2:
      FETCHPAR(ChnN[ChnNr],TempStr);
      FETCHPAR(SFOName,&TempDouble);
      break;
    default:
      FETCHPARS(ChnN[ChnNr],TempStr);
      FETCHPARS(SFOName,&TempDouble);
    }

    TempDouble = ((TempDouble-BF1) * 1e6) - SR;

    if (DBL >= 2)
      fprintf(debug,"%s='%s' ",SFOName,TempStr);

    /* If NUC is not "off" and O1 is within +/- SW, THEN it is used as Suppr. Frequ */
    if ( (strcmp(TempStr,"off")!=0) && (fabs(TempDouble - FFrq) < SW*BF1) )
    {

      /* Return Hz */
      if (Frq != NULL)
      {
	Frq[FrqAnz] = TempDouble;
	if (DBL >= 2) fprintf(debug,"%.2fHz ",Frq[FrqAnz]);
      }

      /* Return PPM */
      if (FrqP != NULL)
      {
	FrqP[FrqAnz] = TempDouble / BF1;
	if (DBL >= 2) fprintf(debug,"%.3fppm ",FrqP[FrqAnz]);
      }

      /* Increase number of frequencies to activate THIS SFrq */
      FrqAnz++;
    }
  }

  if (DBL >= 2) fprintf(debug,"\n");

  if (debug)
  {
    fprintf(debug," RESULT %d Frequencies @ ",FrqAnz);
    for ( FrqNr=0; FrqNr < FrqAnz; FrqNr++ )
    {
      fprintf(debug," %.3f",FrqP[FrqNr]);
    }
    fprintf(debug,"ppm\n\\END FUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  return FrqAnz;
}
/* END FUNCTION ReadFrqOn_2 ***************************************************/


/* FUNCTION AUMessage 000626 **************************************************/
/* Creates a message into the debugfile use only for fixed text		      */
/* eub 041124 flush also before message					      */
/******************************************************************************/
void AUMessage( const char *Message )
{
  if (debug)
  {
    fflush(debug); fprintf(debug,Message); fflush(debug);
  }
}
/* END FUNCTION AUMessage *****************************************************/



/* BEGIN FUNCTION OnFlTimeRes 001115 ******************************************/
/* Returns the timeconsuption per row in seconds			      */
/* eub 020628 set timeresolution via 1 SWH, do not use IN0		      */
/* eub 031206 Resolution by comparison with different 1TD		      */
/* eub 041124 Sets TD0=0 for calculation				      */
/******************************************************************************/
int OnFlTimeRes( const char *curdat, double *TimeRes )
{
  static const char FktId[] = "OnFlTimeRes 031206";
  int	 TD1Set,ExptTime,ExptTime2;
  int	 DSSet,NSSet;
  double  TempDouble;

  int	 TD1Min = 8;
  int	 TD1Max = 108;
  int	 TD0Set;

  if(debug)
  {
    fprintf(debug,"\n/START FUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  FETCHPAR1("TD",&TD1Set);
  FETCHPAR("NS",&NSSet);
  FETCHPAR("DS",&DSSet);
  FETCHPAR("TD0",&TD0Set);

  /* Total experiment time per DS + NS */
  STOREPAR1("TD",TD1Min);
  /* don't know if pulsprograms uses TD0 loop */
  STOREPAR("TD0",1);
  /* XWINNMR ExptTime = CalcExpTime( curdat ); */
  ExptTime = CalcExpTime(); /* TOPSPIN */
  /* Prev. Version, calculate by DS and NS comparison */
  /* TimeRes = (float)NSSet * (float)ExptTime/(float)(TD1Set * NSSet + DSSet ); */

  /* Calculate experiment time with changed 1TD */
  STOREPAR1("TD",TD1Max);
  /* XWINNMR ExptTime2 = CalcExpTime( curdat ); */
  ExptTime2 = CalcExpTime(); /* TOPSPIN */
  STOREPAR1("TD",TD1Set);
  STOREPAR1("TD0",TD0Set);

  /* Measure timeconsumption per row */
  *TimeRes = (double)(ExptTime2 - ExptTime) / (double)(TD1Max - TD1Min);

  /* for xwin 3.0 and earlier via IN0 and ND0
  STOREPAR1("IN0",*TimeRes/60.);
  STOREPAR1S("IN0",*TimeRes/60.);
  STOREPAR1("ND0",2);
  STOREPAR1S("ND0",2);	*/

  /* for xwin 3.1ff set resolution via 1 SWH */
  TempDouble = 1. / ( *TimeRes/30.);
  STOREPAR1("SWH",TempDouble );
  STOREPAR1S("SWH",TempDouble );

  if (debug)
  {
    fprintf(debug," Timing %dsec/%drow = %.3fsec/row\n"
      ,(int)(ExptTime2 - ExptTime),(int)(TD1Max-TD1Min),*TimeRes);
    fprintf(debug,"\\END\tFUNCTION '%s'->(%d)\n\n",FktId,0);
    fflush(debug);
  }
  return(0);
}
/* END FUNCTION OnFlTimeRes ***************************************************/

/* FUNCTION ReadSregLst *******************************************************/
/* Reads the regions from a SREGLST and returns it as an array of double      */
/* values								      */
/* Borders are returned in format Left,right,left,right			      */
/* Complete path must be given, typically getstan(0,0)lists/f1/f1listname     */
/******************************************************************************/
int ReadSregLst
( const char *SregP, int RegAnzMax, double *Reg )
{
  static const char FktId[] = "ReadSregLst 001128";

  int RegAnz = 0;
  int RegNr;
  double TempDbl1,TempDbl2;

  char TempStr[PATH_MAX];
  FILE *SregF;

  if (debug && DBL>0)
  {
    (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }

  /* Find frequency list */
  if (DBL >= 2)
    (void)fprintf(debug,"SREGLST: '%s'\n",SregP);

  SregF = fopen(SregP,"r");
  if ( SregF == NULL )
  {
    if (debug) (void)fprintf(debug,"ERROR opening '%s'\n",SregP);
    RegAnz= 0;
  }
  else
  {
    /* Read FileHeader */
    fgets(TempStr,STRING_MAXLENGTH-1,SregF);
    if ( DBL >= 3 )
      (void)fprintf(debug,"Header:\n'%s'\n",TempStr);

    /* Read file into ARRAY */
    for( RegNr = 0; RegNr < RegAnzMax; RegNr++)
    {
      if( fscanf(SregF,"%lf%lf",&TempDbl1,&TempDbl2) < 2)
      {
	/* End of File reached */
	break;
      }

      if ( Reg != NULL )
      {
	*(Reg + 2*RegNr    ) = TempDbl1;
	*(Reg + 2*RegNr + 1) = TempDbl2;
      }

      if (DBL >= 3)
	(void)fprintf(debug
	,"(%3d) %.3f %.3f\n"
	,RegNr,*(Reg+2*RegNr),*(Reg+2*RegNr+1));

      /* Entry 'FrqNr' sucesfully read */
      RegAnz = RegNr + 1;
    }
    (void)fclose(SregF);
  }

  if(debug)
  {
    fprintf(debug,"<FUNCTION %s: read %d nonsolvent regions\n",FktId,RegAnz);
    fflush(debug);
  }

  return(RegAnz);
}
/* END FUNCTION ReadSregLst ***************************************************/


/* FUNCTION WritSregLst *******************************************************/
/* Write an array of double into a SREGLST				      */
/* Borders must be given in format Left,right,left,right		      */
/* Complete path must be given, typically getstan(0,0)lists/f1/f1listname     */
/* 010519 debugging messages changed					      */
/* 050818 file write with "wt"						      */
/******************************************************************************/
int WriteSregLst
( const char *SregP, int RegAnz, double *Reg )
{
  static const char FktId[] = "WriteSregLst 050818";

  int RegNr;
  const char* HeaderStr = "P 1.0\n";
  FILE *SregF;

  if (debug)
  {
    if(DBL > 0)
    {
      (void)fprintf(debug,"/START\tFUNCTION '%s'\n%d regions",FktId,RegAnz);
      for( RegNr = 0; RegNr < RegAnz; RegNr++)
      {
	(void)fprintf(debug,"[%.3f %.3fppm]",*(Reg+RegNr*2),*(Reg+RegNr*2+1));
      }
      fprintf(debug,"\n");
      if (DBL >= 2) (void)fprintf(debug,"to SREGLST: '%s'\n",SregP);
    }
    else
    {
      (void)fprintf(debug,"<FUNCTION '%s': write %d regions\n",FktId,RegAnz);
    }
    fflush(debug);
  }

  /* Find frequency list */
  SregF = fopen(SregP,"wt");
  if ( SregF == NULL )
  {
    if (debug) (void)fprintf(debug,"ERROR opening '%s'\n",SregP);
    RegNr = 0;
  }
  else
  {
    /* Read FileHeader */
    fprintf(SregF,HeaderStr);

    /* Read file into ARRAY */
    for( RegNr = 0; RegNr < RegAnz; RegNr++)
    {
      fprintf(SregF,"%.2f %.2f",*(Reg+RegNr*2),*(Reg+RegNr*2+1));
    }
    (void)fclose(SregF);
  }

  if(debug && DBL>0)
  {
    fprintf(debug,"\\END\tFUNCTION '%s'->(%d)\n",FktId,RegNr);
    fflush(debug);
  }

  return(RegNr);
}
/* END FUNCTION WriteSregLst **************************************************/


/* FUNCTION ReadIntrng ********************************************************/
/* Reads the Integral region from curd					      */
/* 010601 currently only format without Bias & Slope supported		      */
/* 010610 read into STRING first					      */
/******************************************************************************/
int ReadIntrng
( const char *IntrngP, int RegAnzMax, double *Reg, double *Bias, double *Slope)
{
  static const char FktId[] = "ReadIntrng 010602";

  int RegAnz = 0;
  int RegNr;
  double TempDbl1,TempDbl2;
  int AnzVal = 2;	/* from ABS 2, from integ 4 */

  char TempStr[STRING_MAXLENGTH];
  /* FILE *IntrngF; */
  FILE *IntrngF;

  if (debug)
  {
    if(DBL>0)
      (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    else
      (void)fprintf(debug,"<FUNCTION '%s':",FktId);
    fflush(debug);
  }

  if( Bias == NULL )
    AnzVal = 2;

  strcpy(TempStr,"");

  IntrngF = fopen(IntrngP,"r");
  if ( IntrngF == NULL )
  {
    if (debug) (void)fprintf(debug,"ERROR opening '%s'\n",IntrngP);
    RegAnz= 0;
  }
  else
  {
    if ( debug )
    {
      (void)fprintf(debug,"Source is '%s'\n",IntrngP);
      (void)fprintf(debug,"TempStr before:\n'%s'\n",TempStr);
    }
    /* Read FileHeader */
    /* fgets(TempStr,(int)(STRING_MAXLENGTH-1),IntrngF); */
    (void)fgets(TempStr,80,IntrngF);
    if ( debug )
      (void)fprintf(debug,"Header:\n'%s'\n",TempStr);
    (void)fgets(TempStr,80,IntrngF);
    if ( debug )
      (void)fprintf(debug,"Header:\n'%s'\n",TempStr);
    (void)fgets(TempStr,80,IntrngF);
    if ( debug )
      (void)fprintf(debug,"Header:\n'%s'\n",TempStr);
    (void)fgets(TempStr,80,IntrngF);
    if ( debug )
      (void)fprintf(debug,"Header:\n'%s'\n",TempStr);
    if( TempStr[0] == 'A' )
    {
      fgets(TempStr,STRING_MAXLENGTH-1,IntrngF);
      if ( debug)
	(void)fprintf(debug,"'intrng' with BIAS and SLOPE found, read second line:\n'%s'\n",TempStr);
    }

    /* Read file into ARRAY */
    for( RegNr = 0; RegNr < RegAnzMax; RegNr++)
    {
      if( fgets(TempStr,STRING_MAXLENGTH-1,IntrngF) == 0
	|| sscanf(TempStr,"%lf%lf",&TempDbl1,&TempDbl2) < AnzVal
	)
      {
	/* end of file (empty string) or illegal line reached */
	break;
      }

      /* In any case return borders */
      *(Reg + 2*RegNr	 ) = TempDbl1;
      *(Reg + 2*RegNr + 1) = TempDbl2;

      if (DBL >= 1)
      {
	(void)fprintf(debug,"(%3d) %.3f %.3f\n",RegNr,TempDbl1,TempDbl2);
	fflush(debug);
      }

      /* Entry 'FrqNr' sucesfully read */
      RegAnz = RegNr + 1;
    }
    (void)fclose(IntrngF);
  }

  if(debug)
  {
    if(DBL>0)
      fprintf(debug," RESULT %d regions from\n '%s'\n\\END\tFUNCTION '%s'->(%d)\n"
      ,RegAnz,IntrngP,FktId,RegAnz);
    else
      fprintf(debug," read %d regions\n",RegAnz);
    fflush(debug);
  }

  return(RegAnz);
}
/* END FUNCTION ReadIntrng ****************************************************/


/* FUNCTION ReadIntrng2 *******************************************************/
/* Reads the Integral region from curd					      */
/* 010601 currently only format without Bias & Slope supported		      */
/* 010610 read into STRING first					      */
/******************************************************************************/
int ReadIntrng2
( const char *IntrngP, int RegAnzMax, double *Reg, double *Bias, double *Slope)
{
  static const char FktId[] = "ReadIntrng2 030202";

  int RegAnz = 0;
  int RegNr;
  double TempDbl1,TempDbl2,TempDbl3,TempDbl4;
  int AnzVal = 2;	/* from ABS 2, from integ 4 */

  char TempStr[STRING_MAXLENGTH];
  /* FILE *IntrngF; */
  FILE *IntrngF;

  if (debug)
  {
    if(DBL>0)
      (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    else
      (void)fprintf(debug,"<FUNCTION '%s':",FktId);
    fflush(debug);
  }

  strcpy(TempStr,"");

  IntrngF = fopen(IntrngP,"r");
  if ( IntrngF == NULL )
  {
    if (debug) (void)fprintf(debug,"ERROR opening '%s'\n",IntrngP);
    RegAnz= 0;
  }
  else
  {
    if ( debug )
    {
      (void)fprintf(debug,"Source is '%s'\n",IntrngP);
    }
    /* Read FileHeader */
    /* fgets(TempStr,(int)(STRING_MAXLENGTH-1),IntrngF); */
    (void)fgets(TempStr,(int)(STRING_MAXLENGTH-1),IntrngF);

    /* Must find out type of integral file */
    if( TempStr[0]=='P' )
    {
      if ( debug )
	(void)fprintf(debug,"Simple 'intrng' found Header:\n'%s'\n",TempStr);
      AnzVal = 2;
    }
    else
    {
      if ( debug )
	(void)fprintf(debug,"'intrng' with bias&slope found Header:\n'%s'\n",TempStr);
      if( Bias != NULL && Slope != NULL )
	AnzVal = 4;
      (void)fgets(TempStr,(int)(STRING_MAXLENGTH-1),IntrngF);
      if ( debug )
	(void)fprintf(debug,"Header #2:\n'%s'",TempStr);
    }

    /* Read file into ARRAY */
    for( RegNr = 0; RegNr < RegAnzMax; RegNr++)
    {
      if( fgets(TempStr,STRING_MAXLENGTH-1,IntrngF) == 0
	|| sscanf(TempStr,"%lf%lf%lf%lf",&TempDbl1,&TempDbl2,&TempDbl3,&TempDbl4) < AnzVal
	)
      {
	/* end of file (empty string) or illegal line reached */
	break;
      }

      /* In any case return borders */
      *(Reg + 2*RegNr	 ) = TempDbl1;
      *(Reg + 2*RegNr + 1) = TempDbl2;
      if (DBL >= 1)
      {
	(void)fprintf(debug,"(%3d) %.3f %.3f\n",RegNr,TempDbl1,TempDbl2);
	fflush(debug);
      }

      if( AnzVal == 4 )
      {
	/* Return bias and slope */
	*(Bias + RegNr	) = TempDbl3;
	*(Slope + RegNr ) = TempDbl4;
	if (DBL >= 1)
	{
	  (void)fprintf(debug,"(%3d) %.3f %.3f\n",RegNr,TempDbl3,TempDbl4);
	  fflush(debug);
	}
      }


      /* Entry 'FrqNr' sucesfully read */
      RegAnz = RegNr + 1;
    }
    (void)fclose(IntrngF);
  }

  if(debug)
  {
    if(DBL>0)
      fprintf(debug," RESULT %d regions from\n '%s'\n\\END\tFUNCTION '%s'->(%d)\n"
      ,RegAnz,IntrngP,FktId,RegAnz);
    else
      fprintf(debug," read %d regions\n",RegAnz);
    fflush(debug);
  }

  return(RegAnz);
}
/* END FUNCTION ReadIntrng2 ***************************************************/


/* FUNCTION ReadInteg *********************************************************/
/* Reads the Integral region from file created with LI			      */
/* Reg[2n]/Reg[2n+1] contains begin/end of the regions			      */
/* Int[n] contains the integral						      */
/* Reg and/or Int = NULL if the result shall not be reported		      */
/******************************************************************************/
int ReadInteg
( const char *InputFP, int RegAnzMax, double *Reg, double *Int)
{
  static const char FktId[] = "ReadInteg 100203";

  /* Inputfile */
  FILE *InputF;

  int	  AnzVal = 4;  /* Entries pre line = nr, left, right, intensity */
  int	  HeaderLines = 5;  /* Number of header lines */

  /* temporary variables for the input */
  char	  TempStr[STRING_MAXLENGTH];
  double  TempDbl1,TempDbl2,TempDbl3;
  int	  TempInt;

  /* number of regions */
  int RegNr = 0;


  if (debug)
  {
    if(DBL>0)
      (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    else
      (void)fprintf(debug,"<FUNCTION '%s':",FktId);
    fflush(debug);
  }

  strcpy(TempStr,"");

  InputF = fopen(InputFP,"r");
  if ( InputF == NULL )
  {
    if (debug)
      (void)fprintf(debug,"ERROR opening '%s'\n",InputFP);
  }
  else
  {
    if ( DBL>0 )
    {
      (void)fprintf(debug,"Source is '%s'\n",InputFP);
      fflush(debug);
    }

    /* Input of header, the lines are discarded */
    for(TempInt=1; TempInt<=HeaderLines; TempInt++ )
    {
      (void)fgets(TempStr,(int)(STRING_MAXLENGTH-1),InputF);
      if ( DBL>=1 )
	(void)fprintf(debug,"Header #%d:\n'%s'",TempInt,TempStr);
    }

    /* Read file into ARRAY */
    for( RegNr = 0; RegNr < RegAnzMax; RegNr++)
    {
      if( fgets(TempStr,STRING_MAXLENGTH-1,InputF) == 0
	|| sscanf(TempStr,"%d%lf%lf%lf"
	,&TempInt,&TempDbl1,&TempDbl2,&TempDbl3) < AnzVal
	)
      {
	/* end of file (empty string) or illegal line reached */
	RegNr--;
	break;
      }

      /* Borders of the region */
      if(Reg!=NULL)
      {
	*(Reg + 2*RegNr    ) = TempDbl1;
	*(Reg + 2*RegNr + 1) = TempDbl2;
      }

      /* Integral values */
      if(Int!=NULL)
	*(Int + RegNr) = TempDbl3;

      if ( DBL>0 )
      {
	(void)fprintf(debug,"(%3d) %.3f to %.3f %.5f\n"
	  ,TempInt,TempDbl1,TempDbl2,TempDbl3);
	fflush(debug);
      }

    }
    (void)fclose(InputF);
  }

  RegNr++;

  if(debug)
  {
    if(DBL>0)
      fprintf(debug
      ," RESULT %d regions from\n '%s'\n\\END\tFUNCTION '%s'->(%d)\n"
      ,RegNr,InputFP,FktId,RegNr);
    else
      fprintf(debug," read %d regions\n",RegNr);
    fflush(debug);
  }

  return RegNr;
}
/* END FUNCTION ReadInteg *****************************************************/


/* FUNCTION mzero *************************************************************/
/* Writes ZERO intensity values to multiple regions defined with 'Reg'	      */
/******************************************************************************/
int mzero( const char *curdat, int RegAnz, double *Reg )
{
  static const char FktId[] = "mzero 010519";

  char path1r1i[PATH_MAX];
  char* buf;
  int si, cnt;
  long start, size;
  float offset;
  double sf, sw_p;
  int RegNr;

  if (debug)
  {
    if(DBL > 0)
    {
      (void)fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
      (void)fprintf(debug,"%d regions ",RegAnz);
      for( RegNr=0; RegNr < RegAnz; RegNr++ )
      {
	fprintf(debug,"[%.3f - %.3fppm] "
	  ,*(Reg+RegNr*2),*(Reg+RegNr*2+1) );
      }
      (void)fprintf(debug,"\n");
    }
    else
    {
      (void)fprintf(debug,"<FUNCTION '%s': zero %d regions\n",FktId,RegAnz);
    }
    fflush(debug);
  }

  /* Get processing parameters from current dataset */
  FETCHPARS("SI",&si);
  FETCHPARS("SF",&sf);
  FETCHPARS("SW_p",&sw_p);
  FETCHPARS("OFFSET",&offset);
  (void)sprintf(path1r1i,PROCPATH("1r"));
  if(DBL >= 1)
  {
    fprintf(debug
      ,"PARAMETERS:\nSI %d SF %.7fMHz SW_p %.3fppm OFFSET %.3fppm\nin '%s'\n"
      ,si,sf,sw_p,offset,path1r1i);
    fflush(debug);
  }

  for( RegNr=0; RegNr<RegAnz; RegNr++ )
  {
    start = (long)((offset - *(Reg+RegNr*2) ) * sf * si / sw_p);
    if (start < 0)
    {
      if (debug)
	(void)fprintf(debug,"ERROR Start = %ld <0 for region %d\n",start,RegNr);
      start = 0;
    }

    size = (long)((offset - *(Reg+RegNr*2+1)) * sf * si / sw_p);
    if (size > (long)si)
    {
      if (debug)
	(void)fprintf(debug,"ERROR size = %ld > SI %d for region %d\n",size,si,RegNr);
      size = si;
    }

    if (size <= start)
    {
      if (debug)
	(void)fprintf(debug,"ERROR start %ld size %ld for region %d\n",start,size,RegNr);
      break;
    }

    if ((buf = calloc(size - start, sizeof(int))) == 0)
    {
      if (debug)
	(void)fprintf(debug,"ERROR not enough buffer space\n");
      break;
    }

    start *= sizeof(int);
    size  *= sizeof(int);
    size  -= start;

    cnt = 2;

    (void)sprintf(path1r1i,PROCPATH("1r"));
    do
    {
      if (access(path1r1i, F_OK) == 0)
      {
	int fd = open(path1r1i, O_RDWR);

	if (fd == -1)
	{
	  Perror(DEF_ERR_OPT, path1r1i);
	}
	else
	{
	  if (lseek(fd, start, SEEK_SET) < 0 )
	  {
	    Perror(DEF_ERR_OPT, path1r1i);
	  }
	  else
	  {
	    if (write(fd, buf, (unsigned long)size) < 0)
	      Perror(DEF_ERR_OPT, path1r1i);
	  }

	  (void)close(fd);
	}
      }

      (void)sprintf(path1r1i,PROCPATH("1i"));
    }
    while (--cnt);

    free(buf);

    /* for debugging show spectrum with ZEROs */
    if( DBL > 1 )
      VIEWDATA;

  }

  if(debug && DBL>0)
  {
    fprintf(debug,"\\END\tFUNCTION '%s'\n",FktId);
    fflush(debug);
  }
  return(0);
}
/* END FUNCTION mzero *********************************************************/


/* FUNCTION ReadFrqUser *******************************************************/
/* Reads an array of double values from the commandline			      */
/******************************************************************************/
int ReadFrqUser
( const char *curdat, int FrqAnzMax, float SR, int SFrqAnzAkt, double *Frq, double *FrqP )
{
  static const char FktId[] = "ReadFrqUser 030130";

  int FrqAnz = 0;
  int FrqNr;
  double TempDouble;
  double BF1;

  int	GetPPM = 0;
  char	Unit[4] = "Hz";

  char TempStr[PATH_MAX] = "";
  char Answer[PATH_MAX] = "";

  if (debug && DBL>0)
  {
    (void)fprintf(debug,"/START\tFUNCTION '%s'\nSR %.3f Start with %d entries\n"
      ,FktId,SR,SFrqAnzAkt);
    fflush(debug);
  }

  FETCHPAR("BF1",&BF1);

  /* Ask for PPM or HZ */
  if( FrqP != NULL )
  {
    GetPPM = 1;
    strcpy(Unit,"ppm");
  }

  /* Ask frequencies from USER */
  FrqNr = 0;
  FrqAnz = 0;
  do
  {
    if (DBL >= 2)
      fprintf(debug,"Entry #%d = ",FrqNr);

    /* Set Startvalue, some entries are not defined */
    if ( FrqNr > SFrqAnzAkt-1 )
    {
      if ( FrqNr == 0 )
      {
	if (DBL >= 2)
	  fprintf(debug,"default value 0.0\n");
	TempDouble = (double)0.;
      }
      else
      {
	TempDouble = *(FrqP+FrqNr-1);
	if (DBL >= 2)
	  fprintf(debug," previous value #%d %.3f\n"
	  ,FrqNr-1,TempDouble);
      }
    }
    else
    {
      TempDouble = *(FrqP+FrqNr);
      if (DBL >= 2)
	fprintf(debug," startvalue %.3f\n",TempDouble);
    }

    /* Propose previous value from list */
    sprintf(Answer,"%.3f ppm",TempDouble + (double)SR/BF1);
    sprintf(TempStr,"Frequency #%d [%s]",FrqNr+1,Unit);
    GETSTRING(TempStr,Answer);

    if ( sscanf(Answer,"%lf",&TempDouble) < 1 )
    {
      /* No valid answer, end reached? */
      if ( !Proc_err(ERROPT_AK_CAN,"End of frequency list reached?") )
	break;
    }
    else
    {
      /* Answer was OK, use as frequency */
      if (DBL >= 1)
      {
	fprintf(debug,"%d %.3f -> ",FrqNr,TempDouble);
	fflush(debug);
      }

      if ( GetPPM )
      {
	/* Answer was in PPM */
	FrqP[FrqNr] = TempDouble - (double)SR/BF1;
	if (DBL >= 1)
	{
	  fprintf(debug,"%.3fppm\n",FrqP[FrqNr]);
	  fflush(debug);
	}

	if ( Frq != NULL )
	  Frq[FrqNr] = TempDouble*BF1 - (double)SR;
      }
      else
      {
	/* Answer was in HZ */
	if ( FrqP != NULL )
	{
	  FrqP[FrqNr] = (TempDouble - (double)SR) / BF1;
	  if (DBL >= 1)
	  {
	    fprintf(debug,"%.3fppm\n",FrqP[FrqNr]);
	    fflush(debug);
	  }

	}

	if ( Frq != NULL )
	{
	  Frq[FrqNr] = TempDouble - (double)SR;
	  if (DBL >= 1)
	    fprintf(debug,"%.3fHz\n",Frq[FrqNr]);
	}
      }

      /* FrqAnz successfully increased */
      FrqAnz++;
      /* set FrqNr to NEXT frequency */
      FrqNr++;
    }
  }
  while( FrqAnz < FrqAnzMax );


  if (debug)
  {
    if (DBL > 0)
    {
      fprintf(debug,"%d frequencies",FrqAnz);
      /* for( FrqNr = 0; FrqNr < FrqAnz; FrqNr++)
      {
      fprintf(debug," %.3f",*(FrqP+FrqNr));
    } */
      fprintf(debug,"Hz\n\\END\tFUNCTION '%s'->(%d)\n"
	,FktId,FrqAnz);
    }
    else
    {
      fprintf(debug,"\\FUNCTION '%s read %d frequencies\n"
	,FktId,FrqAnz);
    }
    fflush(debug);
  }

  return FrqAnz;
}
/* END FUNCTION ReadFrqUser ***************************************************/



/* FUNCTION DoWDW *************************************************************/
/* executes windowfunction as defined in 'edp'				      */
/******************************************************************************/
int DoWDW( char *curdat )
{
  int WDWSet = 0;

  FETCHPAR("WDW",&WDWSet);
  if (debug)
  {
    fprintf(debug,"Apply windowfunction #%d\n",WDWSet);
    fflush(debug);
  }
  switch( WDWSet )
  {
  case 1:
    EM;
    break;
  case 2:
    GM;
    break;
  case 3:
    SINM;
    break;
  case 4:
    QSIN;
    break;
  }

  return 0;
}
/* END FUNCTION DoWDW *********************************************************/

/* BEGIN FUNCTION SetupOnflow *************************************************/
/* Interactiv setup of the parameters concerning the ONFLOW timing	      */
/* Change NS and D1 to get time resolution, Change Runtime to get 1 TD	      */
/* 010920 eub loop changed, output compact				      */
/******************************************************************************/
int SetupOnflow( const char *curdat )
{
  int NSSet;
  int TD1Set;
  int TempInt;
  float D1Set;
  double TimeRes;
  char TempStr[PATH_MAX],Answer[PATH_MAX];
  double Runtime;
  int	DoDialog = 0;

  (void)OnFlTimeRes( curdat, &TimeRes );
  FETCHPAR("NS",&NSSet);
  FETCHPAR("D 1",&D1Set);
  FETCHPAR1("TD",&TD1Set);
  Runtime = TimeRes * (double)TD1Set/60.;

  /* current settings */
  do
  {
    if( DoDialog )
    {
      /* prepare Answer */
      sprintf(Answer,"%d %.2f %.1f ",NSSet,D1Set,Runtime);

      /* Ask user */
      GETSTRING("Enter NS D1 Runtime [min] ",Answer);

      /* Check answer */
      TempInt = sscanf(Answer,"%d %f %lf",&NSSet,&D1Set,&Runtime);

      /* Must set parameters immediately for calculation */
      STOREPAR("NS",NSSet);
      STOREPAR("D 1",D1Set);
      (void)OnFlTimeRes( curdat, &TimeRes );
      TD1Set = (int)(Runtime/(TimeRes / 60.));
      STOREPAR1("TD",TD1Set);
    }

    DoDialog = 1;
    sprintf(TempStr
      ,"-- ONFLOW TIMING ----------------------\n"
      "Timeresolution %5.2fmin or %2.0fsec/row\n"
      "Runtime        %4.1f min\n"
      "( NS %d  D1 %.2fs  1TD %d rows )"
      ,(TimeRes/60.),TimeRes,Runtime,NSSet,D1Set,TD1Set);
  }
  while( Proc_err(ERROPT_AK_CAN,TempStr) );

  if(debug)
  {
    fprintf(debug
      ,"<FUNCTION SetupOnflow: Runtime %.2fm Res %.2fm NS %d D1 %.2f 1TD %d\n"
      ,Runtime,(TimeRes/60.),NSSet,D1Set,TD1Set);
    fflush(debug);
  }

  return((int)(TimeRes));
}
/* END FUNCTION SetupOnflow ***************************************************/


/******************************************************************************/
/*      Round number to next larger power of 2.				      */
/******************************************************************************/

static int pow_next(int num)
{
  int ret = 1;
  while (ret < num) ret <<= 1;
  return ret;
}

/* BEGIN FUNCTION SetupOnflow2 ************************************************/
/* Interactiv setup of the parameters concerning the ONFLOW timing	      */
/* Requests Duration and time resolution, changes NS and D1 to get resolution */
/* Changes 1 TD to get runtime						      */
/* Minimum NS respected, adapt NS to get minimum D1 changes		      */
/******************************************************************************/
int SetupOnflow2( const char *curdat )
{
  static const char FktId[] = "SetupOnflow2 031209";

  int	TempInt;
  int	DoDialog = 0;
  char	TempStr[PATH_MAX],Answer[PATH_MAX],TUnit[8];

  int	NSMin = 4;
  double D1Min = .2;

  /* originally defined parameters, never change during procedure */
  int	NSSet;
  float D1Set;

  /* Calculated at beginning or changed by user */
  double TimeResSet = 30.; /* time per row in seconds */
  double RunTimeSet = 30.; /* experiment time without DS in minutes */
  int	TD1Set;

  /* temp. parameters */
  int	NS;
  double D1;

  double TimeResBlock,TimeRes;
  double RunTime;
  int	NSBlocks = 1;

  FETCHPAR("NS",&NSSet);
  FETCHPAR("D 1",&D1Set);
  FETCHPAR1("TD",&TD1Set);


  NS = NSSet;
  D1 = D1Set;

  /* current settings */
  do
  {
    if( DoDialog )
    {

      /* Run this question only the first time */
      if( DoDialog == 1 )
      {
	/* Preferred value for D1 */
	GETFLOAT("Requested relaxation delay [sec] ",D1Set);
	if( D1Set < .001 || D1Set > 1000. )
	  D1Set = 0.5;

	GETINT("Minimum number of scans ",NSMin);
	if( NSMin < 1 || NSMin > 32 )
	  NSMin = 4;
      }

      /* Duration of experiment -> RunTimeSet */
      GETDOUBLE("Length of chromatogram [min] ",RunTimeSet);
      if( RunTimeSet > 60.*24. || RunTimeSet < 1. )
	RunTimeSet = 30.;

      /* Timeresolution -> TimeResSet */
      (void)sprintf(Answer,"%.1f sec",TimeResSet);
      GETSTRING("Width of chromatographic Peaks ",Answer);
      (void)sscanf(Answer,"%lf %s",&TimeResSet,TUnit);
      if( TUnit[0] == 'm' || TUnit[0] == 'M' )
	TimeResSet = TimeResSet * 60.;
      if( TimeResSet > 600. || TimeResSet < 1. )
	TimeResSet = 30.;

      /* Calc. TimeResBlock for a Block of NSMin Scans */
      /* and the originally requested D1 */
      STOREPAR("NS",NSMin);
      STOREPAR("D 1",D1Set);

      (void)OnFlTimeRes( curdat, &TimeResBlock );
      /* XWINNMR RunTime = CalcExpTime(curdat )/60.; */
      RunTime = CalcExpTime()/60.; /* TOPSPIN */

      /* Check timing with closest NS */
      NSBlocks = (int)(TimeResSet/TimeResBlock + .5);
      TimeRes = ((double)NSBlocks * TimeResBlock);
      if(DBL>1)
      {
	fprintf(debug,"First NS: %dx%d=%d leads to %.3fsec/row requested %.3fsec/row\n"
	  ,NSBlocks,NSMin,NSBlocks*NSMin,TimeRes,TimeResSet);
	fflush(debug);
      }
      if( D1Set - (TimeRes - TimeResSet)/(double)(NSBlocks*NSMin) < D1Min )
      {
	/* Time differenct cannot be compensated by D1 */
	/* so change NS and recalculate the TimeRes */
	if(DBL>1)
	{
	  fprintf(debug,"Timedifference %.1fsec/row = %.1fsec/scan too large, decrease NS by %d to %d\n"
	    ,TimeRes,(TimeRes - TimeResSet)/(double)(NSBlocks*NSMin),NSMin,(NSBlocks-1)*NSMin);
	  fflush(debug);
	}
	NSBlocks--;
      }

      /* final check for NS */
      if ( NSBlocks < 1 )
	NSBlocks = 1;
      TimeRes = NSBlocks * TimeResBlock;
      NS = (int)(NSBlocks * NSMin);
      STOREPAR("NS",NS);
      if(DBL>1)
      {
	fprintf(debug,"Final NS: %dx%d=%d with %.3fsec/row\n"
	  ,NSBlocks,NSMin,NS,TimeRes);
	fflush(debug);
      }

      /* NS is now set, so that D1 can compensate the remaining difference */
      /* change D1 to get correct timing */
      D1 = D1Set - (TimeRes - TimeResSet)/(double)NS;
      if( D1 < D1Min )
	D1 = D1Min;

      STOREPAR("D 1",D1);
      if(DBL>1)
      {
	fprintf(debug,"D1 changed from %.3fsec to %.3fsec to compensate %.3fsec/%dscans = %.3fsec\n"
	  ,D1Set,D1,TimeRes-TimeResSet,NS,(TimeRes - TimeResSet)/(double)NS);
	fflush(debug);
      }
    }

    /* Calculate real value for TimeRes with NS and D1 or D1Set */
    (void)OnFlTimeRes( curdat, &TimeRes );

    if( DoDialog )
    {
      /* Calculate TD1Set with new resolution based on new NS and D1 */
      TD1Set = (int)(RunTimeSet*60./TimeRes+.5);
      STOREPAR1("TD",TD1Set);
      if(DBL>1)
      {
	fprintf(debug,"(5)Timeresolution\nNS %d D1 %.3fsec = %.2fsec\n"
	  ,NS,D1,TimeRes);
	fflush(debug);
      }
    }

    /* XWINNMR RunTime = CalcExpTime(curdat)/60.; */
    RunTime = CalcExpTime()/60.; /* TOPSPIN */
    if(DBL>1)
    {
      fprintf(debug,"Runtime with 1TD %d %.1fmin\n",TD1Set,RunTime);
      fflush(debug);
    }

    /* set default values for parameters */
    if( !DoDialog )
    {
      /* Default runtime is runtime calculated without changes */
      RunTimeSet = RunTime;
      /* Default Peakwidth is actual timeresolution */
      TimeResSet = TimeRes;
    }


    DoDialog++;
    sprintf(TempStr
      ,"-- ONFLOW ACQUISITION -----------------\n"
      "Runtime    %4.1fmin %d rows\n"
      "Resolution %4.1fsec %d NS/row D1 %.3fs"
      ,RunTime,TD1Set,TimeRes,NS,D1);
  }
  while( Proc_err(ERROPT_AK_CAN,TempStr) );

  /* Set the 1SI equal or to next power of 2 to number of rows  */
  TempInt = pow_next(TD1Set);
  STOREPAR1("SI",TempInt);

  if(debug)
  {
    fprintf(debug
	,"<FUNCTION %s: RunTime %.2fm Res %.2fm NS %d D1 %.2f 1TD %d 1SI %d\n"
	,FktId,RunTime,(TimeRes/60.),NS,D1,TD1Set,TempInt);
    fflush(debug);
  }

  return((int)(TimeRes));
}
/* END FUNCTION SetupOnflow2 **************************************************/


/* FUNCTION ReScale ***********************************************************/
/* Calculates the scaling factor 'DC' for a default RG and default NS	      */
/* eub 060109 Default values adjusted					      */
/* eub 110124 P1 evalutation						      */
/******************************************************************************/
double ReScale( const char *curdat, float RGRef, int NSRef, double P1Ref, int DoMulc )
{
  static const char FktId[] = "RScale 110124";

  double  DCAct;
  float   RGAct;
  int	  NSAct;
  float	  P1Act = 0.;
  double  DCRef = 1.;

  /* If References are 0, use default values */
  if( RGRef == 0. )
    RGRef = SCALE_RG;
  if( NSRef == 0 )
    NSRef = SCALE_NS;

  FETCHPARS("RG",&RGAct);
  FETCHPARS("NS",&NSAct);

  DCRef = (double)RGRef * (double)NSRef;
  DCAct = DCRef /( (double)NSAct * (double)RGAct );

  if( P1Ref > 0. )
  {
    FETCHPARS("P 1",&P1Act);
    DCAct = DCAct * P1Act / P1Ref;
  }

  /* store scaling factor for usage with MULC */
  STOREPAR("DC",DCAct);

  /* Only apply scaling if requested */
  if( DoMulc && DCAct != 1. )
  {
    MULC;
  }

  if(debug)
  {
    fprintf(debug,"<FUNCTION %s: Scale DC %.3f (RG %.1f->%.1f, NS %d->%d, P1 %.1f->%.1f)\n"
      ,FktId,DCAct,RGAct,RGRef,NSAct,NSRef,P1Act,P1Ref);
    fflush(debug);
  }

  return( DCAct );
}
/* END FUNCTION ReScale *******************************************************/


/* FUNCTION PhaseCorr *********************************************************/
int PhaseCorr( const char *curdat, int PhasingMode )
{
  if( PhasingMode == 0 )
  {
    AUMessage("<FUNCTION 'PhaseCorr': Use existing phase with 'pk'\n");
    PK;
  }
  else
  {
    switch ( PhasingMode )
    {
    case 1:
      /* phc0 and phc1, slow */
      AUMessage("<FUNCTION 'PhaseCorr': Determine phase with 'apk'\n");
      APK;
      break;

    case 2:
      /* phc0 and phc1, slow with special algorythm */
      AUMessage("<FUNCTION 'PhaseCorr': Determine phase with 'apks'\n");
      APKS;
      break;

    case 3:
      AUMessage("<FUNCTION 'PhaseCorr': Determine phase with 'apkf'\n");
      APKF;
      break;

    case 4:
      AUMessage("<FUNCTION 'PhaseCorr': Determine phase with 'apk0'\n");
      APK0;
      break;

    case 5:
    /* strcpy(PHCmd,"lcapkf");
      break; */

    case 10:
      AUMessage("<FUNCTION 'PhaseCorr': Determine phase with 'xau apk0.noe'\n");
      XAU("apk0.noe2","");
      break;

    default:
      if(debug)
	fprintf(debug
	,"<FUNCTION 'PhaseCorr': Phasemode '%d' unknown, Determine phase with 'apk'\n"
	,PhasingMode);
      APK;
    }
  }

  return(0);
}
/* END FUNCTION PhaseCorr *****************************************************/

/* FUNCTION Extract ***********************************************************/
/* eub 090804 compatible for datastructure with & without 'user'	      */
/******************************************************************************/
int Extract( const char *curdat, double From, double To, const char* Unit, const char* ExtrType, int ProcnoTarget)
{
  static const char FktId[] = "Extract 090804";
  int	  RetVal = 0;
  float   OFFSET = 0.; /* Left end of spectrum in PPM, incl. SR, STSR */
  double  SW_p = 0.; /* processed range in Hz, incl. STSI or SI respectively */
  double  SF = 0.;
  int	  SI = 0; /* effective SI of spectrum, incl. effect of STSI */
  float   HZpPT = 0.;
  char	  ResultString[PATH_MAX] ="";
  int	  FromPT,ToPT;
  char	  TitleP[PATH_MAX];


  if (debug)
  {
    fprintf(debug,"/START\tFUNCTION '%s'\n",FktId);
    if(DBL>0)
      fprintf(debug
      ,"From %.3f; To %.3f; Unit '%s'; Type '%s'\n",From,To,Unit,ExtrType);
    fflush(debug);
  }

  if( strstr(ExtrType,"f1")!=NULL )
  {
    if(debug)
    {
      fprintf(debug
	,"ExtrType='%s' read parameters from 2S parameters\n",ExtrType);
    }
    FETCHPARS("OFFSET",&OFFSET);
    FETCHPARS("SW_p",&SW_p);
    FETCHPARS("SF",&SF);
    FETCHPARS("SI",&SI);
    FETCHPARS("HZpPT",&HZpPT);
  }
  else
  {
    if(debug)
    {
      fprintf(debug
	,"ExtrType='%s' read parameters from 1S parameters\n",ExtrType);
    }
    FETCHPAR1S("OFFSET",&OFFSET);
    FETCHPAR1S("SW_p",&SW_p);
    FETCHPAR1S("SF",&SF);
    FETCHPAR1S("SI",&SI);
    FETCHPAR1S("HZpPT",&HZpPT);
  }

  if(debug)
  {
    fprintf(debug
      ,"DATASET\nOFFSET=%.3fppm; SF %.6fMHz; SW_p=%.1fHz; SI=%dpt HZpPT=%.3fHz/pt\n"
      ,OFFSET,SF,SW_p,SI,HZpPT);
    fflush(debug);
  }

  /* Check if limits are inverted */
  if( From < To )
  {
    double TempDouble;

    TempDouble = From;
    From = To;
    To = TempDouble;
  }


  /* convert limits in given units into points */
  if( strstr( Unit, "ppm" )!=0 )
  {
    /* given in ppm */
    FromPT = 1 + (int)((OFFSET-From)*SF/HZpPT);
    ToPT = 1 + (int)((OFFSET-To)*SF/HZpPT);
    if(DBL>0)
    {
      fprintf(debug,"FromPT %d=1 + (%.3fppm-%.3f%s)*%.6fMHz/%.3fHz/pt\n"
	,FromPT,OFFSET,From,Unit,SF,HZpPT);
      fprintf(debug,"ToPT %d=1 + (%.3fppm-%.3f%s)*%.6fMHz/%.3fHz/pt\n"
	,ToPT,OFFSET,To,Unit,SF,HZpPT);
      fflush(debug);
    }
  }else if( strstr( Unit, "Hz" )!=0 )
  {
    /* given in Hz */
    FromPT = 1 + (int)((OFFSET*SF-From)/HZpPT);
    ToPT = 1 + (int)((OFFSET*SF-To)/HZpPT);
    if(DBL>0)
    {
      fprintf(debug,"FromPT %d=1 + (%.3fppm*%.6fMHz-%.3f%s)/%.3fHz/pt\n"
	,FromPT,OFFSET,SF,From,Unit,HZpPT);
      fprintf(debug,"ToPT %d=1 + (%.3fppm*%.6fMHz-%.3f%s)/%.3fHz/pt\n"
	,ToPT,OFFSET,SF,To,Unit,HZpPT);
      fflush(debug);
    }
  }
  else
  {
    /* already given in points */
    FromPT = (int)(From);
    ToPT = (int)(To);
    if(DBL>0)
    {
      fprintf(debug,"FromPT %d=%.3f%s\n",FromPT,From,Unit);
      fprintf(debug,"ToPT %d=%.3f%s\n",ToPT,To,Unit);
      fflush(debug);
    }
  }



  /* outside not valid range possible */
  if( FromPT >= SI || ToPT<= 1 )
  {
    sprintf(ResultString,"Range %d-%d invalid in spectrum %d-%d"
      ,FromPT,ToPT,0,SI);
    RetVal = -1;
    goto EndFunction;
  }

  /* If necessary put borders into spectrum */
  if( FromPT < 1 )
    FromPT = 1;
  if( ToPT > SI )
    ToPT = SI;

  /* outside not valid range possible */
  if( FromPT == ToPT )
  {
    sprintf(ResultString,"Range %d-%d is zero; "
      ,FromPT,ToPT);
    RetVal = -1;
    goto EndFunction;
  }

  /* Create the desired SUM */
  if( strstr(ExtrType,"f1")!=NULL )
  {
    if( strstr(ExtrType,"projp")!=NULL)
    {
      F1PROJP(FromPT,ToPT,ProcnoTarget);
      sprintf(ResultString,"F1PROJP");
    }
    else if(strstr(ExtrType,"projn")!=NULL)
    {
      F1PROJN(FromPT,ToPT,ProcnoTarget);
      sprintf(ResultString,"F1PROJN");
    }
    else
    {
      /* SUM is the default */
      F1SUM(FromPT,ToPT,ProcnoTarget);
      sprintf(ResultString,"F1SUM");
    }
  }
  else
  {
    F2SUM(FromPT,ToPT,ProcnoTarget);
    sprintf(ResultString,"F2SUM");
  }

  /* write source information to new procno */
  strcpy(TitleP, NEWPROCPATH(ProcnoTarget, "title"));

  sprintf(ResultString
    ,"%s  %.3f-%.3f%s (%d-%d) from '%s' %d %d\n"
    ,ResultString,From,To,Unit,FromPT,ToPT,name,expno,procno);
  (void)RepLine( curdat, TitleP, "Source of data  : ", ResultString);

EndFunction:
  if(debug)
  {
    (void)fprintf(debug,"\\END FUNCTION %s: %s\n",FktId,ResultString);
    fflush(debug);
  }
  return(RetVal);
}
/* END FUNCTION Extract *******************************************************/
